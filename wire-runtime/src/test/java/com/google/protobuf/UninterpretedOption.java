// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: ../wire-runtime/src/test/proto/google/protobuf/descriptor.proto at 431:1
package com.google.protobuf;

import com.squareup.wire.Message;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.TypeAdapter;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.Collections;
import java.util.List;
import okio.ByteString;

/**
 * A message representing a option the parser does not recognize. This only
 * appears in options protos created by the compiler::Parser class.
 * DescriptorPool resolves these when building Descriptor objects. Therefore,
 * options protos in descriptor objects (e.g. returned by Descriptor::options(),
 * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 * in them.
 */
public final class UninterpretedOption extends Message<UninterpretedOption> {
  private static final long serialVersionUID = 0L;

  public static final TypeAdapter<UninterpretedOption> ADAPTER = new TypeAdapter.MessageAdapter<UninterpretedOption>() {
    @Override
    public UninterpretedOption read(ProtoReader reader) throws IOException {
      return UninterpretedOption.read(reader);
    }
  };

  public static final String DEFAULT_IDENTIFIER_VALUE = "";

  public static final Long DEFAULT_POSITIVE_INT_VALUE = 0L;

  public static final Long DEFAULT_NEGATIVE_INT_VALUE = 0L;

  public static final Double DEFAULT_DOUBLE_VALUE = 0.0d;

  public static final ByteString DEFAULT_STRING_VALUE = ByteString.EMPTY;

  public static final String DEFAULT_AGGREGATE_VALUE = "";

  public final List<NamePart> name;

  /**
   * The value of the uninterpreted option, in whatever type the tokenizer
   * identified it as during parsing. Exactly one of these should be set.
   */
  public final String identifier_value;

  public final Long positive_int_value;

  public final Long negative_int_value;

  public final Double double_value;

  public final ByteString string_value;

  public final String aggregate_value;

  public UninterpretedOption(List<NamePart> name, String identifier_value, Long positive_int_value, Long negative_int_value, Double double_value, ByteString string_value, String aggregate_value) {
    super("UninterpretedOption");
    this.name = immutableCopyOf(name);
    this.identifier_value = identifier_value;
    this.positive_int_value = positive_int_value;
    this.negative_int_value = negative_int_value;
    this.double_value = double_value;
    this.string_value = string_value;
    this.aggregate_value = aggregate_value;
  }

  private UninterpretedOption(Builder builder) {
    this(builder.name, builder.identifier_value, builder.positive_int_value, builder.negative_int_value, builder.double_value, builder.string_value, builder.aggregate_value);
    setBuilder(builder);
  }

  @Override
  protected void visitFields(Message.Visitor visitor) {
    visitor.repeated(2, "name", name, NamePart.ADAPTER, false);
    visitor.value(3, "identifier_value", identifier_value, TypeAdapter.STRING, false);
    visitor.value(4, "positive_int_value", positive_int_value, TypeAdapter.UINT64, false);
    visitor.value(5, "negative_int_value", negative_int_value, TypeAdapter.INT64, false);
    visitor.value(6, "double_value", double_value, TypeAdapter.DOUBLE, false);
    visitor.value(7, "string_value", string_value, TypeAdapter.BYTES, false);
    visitor.value(8, "aggregate_value", aggregate_value, TypeAdapter.STRING, false);
    visitor.unknowns(this);
  }

  public static UninterpretedOption read(ProtoReader reader) throws IOException {
    Builder builder = new Builder();
    while (reader.hasNext()) {
      int tag = reader.nextTag();
      switch (tag) {
        case 2: builder.name = repeatedMessage(builder.name, reader, NamePart.ADAPTER); break;
        case 3: builder.identifier_value = reader.value(TypeAdapter.STRING); break;
        case 4: builder.positive_int_value = reader.value(TypeAdapter.UINT64); break;
        case 5: builder.negative_int_value = reader.value(TypeAdapter.INT64); break;
        case 6: builder.double_value = reader.value(TypeAdapter.DOUBLE); break;
        case 7: builder.string_value = reader.value(TypeAdapter.BYTES); break;
        case 8: builder.aggregate_value = reader.value(TypeAdapter.STRING); break;
        default: builder.readUnknown(tag, reader); break;
      }
    }
    return builder.build();
  }

  public static final class Builder extends com.squareup.wire.Message.Builder<UninterpretedOption> {
    public List<NamePart> name = Collections.emptyList();

    public String identifier_value;

    public Long positive_int_value;

    public Long negative_int_value;

    public Double double_value;

    public ByteString string_value;

    public String aggregate_value;

    public Builder() {
    }

    public Builder(UninterpretedOption message) {
      super(message);
      if (message == null) return;
      this.name = copyOf(message.name);
      this.identifier_value = message.identifier_value;
      this.positive_int_value = message.positive_int_value;
      this.negative_int_value = message.negative_int_value;
      this.double_value = message.double_value;
      this.string_value = message.string_value;
      this.aggregate_value = message.aggregate_value;
    }

    public Builder name(List<NamePart> name) {
      this.name = canonicalizeList(name);
      return this;
    }

    /**
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     */
    public Builder identifier_value(String identifier_value) {
      this.identifier_value = identifier_value;
      return this;
    }

    public Builder positive_int_value(Long positive_int_value) {
      this.positive_int_value = positive_int_value;
      return this;
    }

    public Builder negative_int_value(Long negative_int_value) {
      this.negative_int_value = negative_int_value;
      return this;
    }

    public Builder double_value(Double double_value) {
      this.double_value = double_value;
      return this;
    }

    public Builder string_value(ByteString string_value) {
      this.string_value = string_value;
      return this;
    }

    public Builder aggregate_value(String aggregate_value) {
      this.aggregate_value = aggregate_value;
      return this;
    }

    @Override
    public UninterpretedOption build() {
      return new UninterpretedOption(this);
    }
  }

  /**
   * The name of the uninterpreted option.  Each string represents a segment in
   * a dot-separated name.  is_extension is true iff a segment represents an
   * extension (denoted with parentheses in options specs in .proto files).
   * E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
   * "foo.(bar.baz).qux".
   */
  public static final class NamePart extends Message<NamePart> {
    private static final long serialVersionUID = 0L;

    public static final TypeAdapter<NamePart> ADAPTER = new TypeAdapter.MessageAdapter<NamePart>() {
      @Override
      public NamePart read(ProtoReader reader) throws IOException {
        return NamePart.read(reader);
      }
    };

    public static final String DEFAULT_NAME_PART = "";

    public static final Boolean DEFAULT_IS_EXTENSION = false;

    public final String name_part;

    public final Boolean is_extension;

    public NamePart(String name_part, Boolean is_extension) {
      super("NamePart");
      this.name_part = name_part;
      this.is_extension = is_extension;
    }

    private NamePart(Builder builder) {
      this(builder.name_part, builder.is_extension);
      setBuilder(builder);
    }

    @Override
    protected void visitFields(Message.Visitor visitor) {
      visitor.value(1, "name_part", name_part, TypeAdapter.STRING, false);
      visitor.value(2, "is_extension", is_extension, TypeAdapter.BOOL, false);
      visitor.unknowns(this);
    }

    public static NamePart read(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      while (reader.hasNext()) {
        int tag = reader.nextTag();
        switch (tag) {
          case 1: builder.name_part = reader.value(TypeAdapter.STRING); break;
          case 2: builder.is_extension = reader.value(TypeAdapter.BOOL); break;
          default: builder.readUnknown(tag, reader); break;
        }
      }
      return builder.build();
    }

    public static final class Builder extends com.squareup.wire.Message.Builder<NamePart> {
      public String name_part;

      public Boolean is_extension;

      public Builder() {
      }

      public Builder(NamePart message) {
        super(message);
        if (message == null) return;
        this.name_part = message.name_part;
        this.is_extension = message.is_extension;
      }

      public Builder name_part(String name_part) {
        this.name_part = name_part;
        return this;
      }

      public Builder is_extension(Boolean is_extension) {
        this.is_extension = is_extension;
        return this;
      }

      @Override
      public NamePart build() {
        if (name_part == null
            || is_extension == null) {
          throw missingRequiredFields(name_part, "name_part",
              is_extension, "is_extension");
        }
        return new NamePart(this);
      }
    }
  }
}
