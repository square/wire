{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wire","text":"<p>\u201cA man got to have a code!\u201d - Omar Little</p> <p>As our teams and programs grow, the variety and volume of data also grows. Success will turn your simple data models into complex ones! Whether your application is storing data to disk or transmitting it over a network, the structure and interpretation of that data should be clear. Consumers work best with data they understand!</p> <p>Schemas describe and document data models. If you have data, you should have a schema.</p>"},{"location":"#protocol-buffers","title":"Protocol Buffers","text":"<p>Google\u2019s Protocol Buffers are built around a great schema language:</p> <ul> <li> <p>It\u2019s cross platform and language independent. Whatever programming language you use, you\u2019ll be   able to use proto schemas with your application.</p> </li> <li> <p>Proto schemas are backwards-compatible and future-proof. You can evolve your schema as your   application loses old features and gains new ones.</p> </li> <li> <p>It\u2019s focused. Proto schemas describe your data models. That\u2019s it.</p> </li> </ul> Protocol Buffer Examples  Here's a [sample message][dinosaur_proto] definition:  <pre><code>syntax = \"proto3\";\n\npackage squareup.dinosaurs;\n\noption java_package = \"com.squareup.dinosaurs\";\n\nimport \"squareup/geology/period.proto\";\n\nmessage Dinosaur {\n  // Common name of this dinosaur, like \"Stegosaurus\".\n  string name = 1;\n\n  // URLs with images of this dinosaur.\n  repeated string picture_urls = 2;\n\n  squareup.geology.Period period = 5;\n}\n</code></pre>  And here's an [enum][period_proto] definition:  <pre><code>syntax = \"proto3\";\n\npackage squareup.geology;\n\n\noption java_package = \"com.squareup.geology\";\n\nenum Period {\n  // 145.5 million years ago \u2014 66.0 million years ago.\n  CRETACEOUS = 0;\n\n  // 201.3 million years ago \u2014 145.0 million years ago.\n  JURASSIC = 1;\n\n  // 252.17 million years ago \u2014 201.3 million years ago.\n  TRIASSIC = 2;\n}\n</code></pre>  This schema language is Protocol Buffers' best feature. You might even use it purely for documentation purposes, such as to describe a JSON API.  Protocol Buffers also defines a compact binary encoding of messages that conform to the schema. This encoding is fast to encode, fast to decode, small to transmit, and small to store. The binary encoding uses numeric tags from the schema, like the `5` for `period` above.  For example, let's encode this dinosaur:  <pre><code>{\n  name: \"Stegosaurus\",\n  period: JURASSIC\n}\n</code></pre>  The encoded value is just 15 bytes:  <pre><code>Hex  Description\n 0a  tag: name(1), field encoding: LENGTH_DELIMITED(2). 1 &lt;&lt; 3 | 2\n 0b  \"Stegosaurus\".length()\n 53  'S'\n 74  't'\n 65  'e'\n 67  'g'\n 6f  'o'\n 73  's'\n 61  'a'\n 75  'u'\n 72  'r'\n 75  'u'\n 73  's'\n 28  tag: period(5), field encoding: VARINT(0). 5 &lt;&lt; 3 | 0\n 02  JURASSIC(2)\n</code></pre>"},{"location":"#why-wire","title":"Why Wire?","text":"<p>The Protocol Buffers schema language and binary encoding are both defined by Google. Wire is an independent implementation from Square that\u2019s specifically designed for Android and Java.</p> <p>For each message type defined in the schema, Wire generates an immutable model class and its builder. The generated code looks like code you\u2019d write by hand: it\u2019s documented, formatted, and simple. Wire\u2019s APIs should feel at home to programmers who like Effective Java.</p> <p>That said, there are some interesting design decisions in Wire:</p> <ul> <li> <p>Wire messages declare <code>public final</code> fields instead of the usual getter methods. This cuts down   on both code generated and code executed. Less code is particularly beneficial for Android   programs.</p> </li> <li> <p>Wire avoids case mapping. A field declared as <code>picture_urls</code> in a schema yields a Java field   <code>picture_urls</code> and not the conventional <code>pictureUrls</code> camel case. Though the name feels awkward   at first, it\u2019s fantastic whenever you use <code>grep</code> or more sophisticated search tools. No more   mapping when navigating between schema, Java source code, and data. It also provides a gentle   reminder to calling code that proto messages are a bit special.</p> </li> <li> <p>Primitive types are always boxed. If a field is absent, its value is <code>null</code>. This is used for   naturally optional fields, such as a dinosaur whose period is unknown. A field may also be null   due to schema evolution: if tomorrow we add a <code>carnivore</code> boolean to our message definition,   today\u2019s data won\u2019t have a value for that field.</p> </li> </ul> Generated Java Code  Here's the compact [generated code][dinosaur_java] for the `Dinosaur` message defined above:  <pre><code>// Code generated by Wire protocol buffer compiler, do not edit.\n// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto\npackage com.squareup.dinosaurs;\n\nimport com.squareup.geology.Period;\nimport com.squareup.wire.Message;\nimport com.squareup.wire.ProtoAdapter;\nimport com.squareup.wire.Syntax;\nimport com.squareup.wire.WireField;\nimport com.squareup.wire.internal.Internal;\nimport java.lang.Object;\nimport java.lang.Override;\nimport java.lang.String;\nimport java.util.List;\nimport okio.ByteString;\n\npublic final class Dinosaur extends Message&lt;Dinosaur, Dinosaur.Builder&gt; {\n  public static final ProtoAdapter&lt;Dinosaur&gt; ADAPTER = ProtoAdapter.newMessageAdapter(Dinosaur.class, \"type.googleapis.com/squareup.dinosaurs.Dinosaur\", Syntax.PROTO_3);\n\n  private static final long serialVersionUID = 0L;\n\n  /**\n   * Common name of this dinosaur, like \"Stegosaurus\".\n   */\n  @WireField(\n      tag = 1,\n      adapter = \"com.squareup.wire.ProtoAdapter#STRING\",\n      label = WireField.Label.OMIT_IDENTITY\n  )\n  public final String name;\n\n  /**\n   * URLs with images of this dinosaur.\n   */\n  @WireField(\n      tag = 2,\n      adapter = \"com.squareup.wire.ProtoAdapter#STRING\",\n      label = WireField.Label.REPEATED,\n      jsonName = \"pictureUrls\"\n  )\n  public final List&lt;String&gt; picture_urls;\n\n  @WireField(\n      tag = 5,\n      adapter = \"com.squareup.geology.Period#ADAPTER\",\n      label = WireField.Label.OMIT_IDENTITY\n  )\n  public final Period period;\n\n  public Dinosaur(String name, List&lt;String&gt; picture_urls, Period period) {\n    this(name, picture_urls, period, ByteString.EMPTY);\n  }\n\n  public Dinosaur(String name, List&lt;String&gt; picture_urls, Period period, ByteString unknownFields) {\n    super(ADAPTER, unknownFields);\n    if (name == null) {\n      throw new IllegalArgumentException(\"name == null\");\n    }\n    this.name = name;\n    this.picture_urls = Internal.immutableCopyOf(\"picture_urls\", picture_urls);\n    if (period == null) {\n      throw new IllegalArgumentException(\"period == null\");\n    }\n    this.period = period;\n  }\n\n  @Override\n  public Builder newBuilder() {\n    Builder builder = new Builder();\n    builder.name = name;\n    builder.picture_urls = Internal.copyOf(picture_urls);\n    builder.period = period;\n    builder.addUnknownFields(unknownFields());\n    return builder;\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (other == this) return true;\n    if (!(other instanceof Dinosaur)) return false;\n    Dinosaur o = (Dinosaur) other;\n    return unknownFields().equals(o.unknownFields())\n        &amp;&amp; Internal.equals(name, o.name)\n        &amp;&amp; picture_urls.equals(o.picture_urls)\n        &amp;&amp; Internal.equals(period, o.period);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode;\n    if (result == 0) {\n      result = unknownFields().hashCode();\n      result = result * 37 + (name != null ? name.hashCode() : 0);\n      result = result * 37 + picture_urls.hashCode();\n      result = result * 37 + (period != null ? period.hashCode() : 0);\n      super.hashCode = result;\n    }\n    return result;\n  }\n\n  public static final class Builder extends Message.Builder&lt;Dinosaur, Builder&gt; {\n    public String name;\n\n    public List&lt;String&gt; picture_urls;\n\n    public Period period;\n\n    public Builder() {\n      name = \"\";\n      picture_urls = Internal.newMutableList();\n      period = Period.CRETACEOUS;\n    }\n\n    /**\n     * Common name of this dinosaur, like \"Stegosaurus\".\n     */\n    public Builder name(String name) {\n      this.name = name;\n      return this;\n    }\n\n    /**\n     * URLs with images of this dinosaur.\n     */\n    public Builder picture_urls(List&lt;String&gt; picture_urls) {\n      Internal.checkElementsNotNull(picture_urls);\n      this.picture_urls = picture_urls;\n      return this;\n    }\n\n    public Builder period(Period period) {\n      this.period = period;\n      return this;\n    }\n\n    @Override\n    public Dinosaur build() {\n      return new Dinosaur(name, picture_urls, period, super.buildUnknownFields());\n    }\n  }\n}\n</code></pre>  The Java code to create and access proto models is compact and readable:  <pre><code>Dinosaur stegosaurus = new Dinosaur.Builder()\n    .name(\"Stegosaurus\")\n    .period(Period.JURASSIC)\n    .build();\n\nSystem.out.println(\"My favorite dinosaur existed in the \" + stegosaurus.period + \" period.\");\n</code></pre>  Each type has a corresponding `ProtoAdapter` that can encode a message to bytes and decode bytes back into a message.  <pre><code>Dinosaur stegosaurus = ...\nbyte[] stegosaurusBytes = Dinosaur.ADAPTER.encode(stegosaurus);\n\nbyte[] tyrannosaurusBytes = ...\nDinosaur tyrannosaurus = Dinosaur.ADAPTER.decode(tyrannosaurusBytes);\n</code></pre>  When accessing a field, use `Wire.get()` to replace null values with the corresponding default:  <pre><code>Period period = Wire.get(stegosaurus.period, Dinosaur.DEFAULT_PERIOD);\n</code></pre>  This is equivalent to the following:  <pre><code>Period period = stegosaurus.period != null ? stegosaurus.period : Dinosaur.DEFAULT_PERIOD;\n</code></pre>"},{"location":"#wire-kotlin","title":"Wire Kotlin","text":"<p>Since version 3.0.0, Wire can generate Kotlin code. See Wire Compiler &amp; Gradle Plugin to learn how to configure your build.</p> <p>Kotlin is a pragmatic and expressive programming language that makes it easy to model data. Here\u2019s how we used Kotlin to model Protocol Buffers messages:</p> <ul> <li>Messages feel like <code>data</code> classes, but in fact they\u2019re not. Compiler still generates <code>equals()</code>,   <code>hashCode()</code>, <code>toString()</code> and <code>copy()</code> for you. Wire does not generate <code>componentN()</code> functions   though, we believe that destructuring declarations are not a good fit for Protocol Buffers: a   change in the schema that removes or adds a field might lead to a situation when your   destructuring declaration still compiles but now describes a completely different subset of   fields, rendering your code incorrect.</li> <li><code>copy()</code> is a substitute for the <code>Builder</code>, which is not used anymore. If your program relies on   the <code>Builder</code> to be present, you may generate code in Java interoperability mode -   Wire Compiler &amp; Gradle Plugin explains how that works.</li> <li>Fields are generated as properties. While this is idiomatic in Kotlin, Java code will now have   to access fields using getters. If your program relies on accessing fields directly, use Java   interoperability mode - the compiler will generate <code>@JvmField</code> annotations for each field.</li> <li>The nullability of each field\u2019s type depends on its label: <code>required</code>, <code>repeated</code> and <code>map</code>   fields get non-nullable types, whereas <code>optional</code> fields are of nullable types.</li> <li> <p>With the exception of <code>required</code> fields, each field has a default value:</p> </li> <li> <p>null for <code>optional</code> fields,</p> </li> <li><code>emptyList()</code> for <code>repeated</code> fields,</li> <li><code>emptyMap()</code> for <code>map</code> fields.</li> </ul> Generated Kotlin Code  Here's the compact [generated code][dinosaur_kotlin] for the `Dinosaur` message defined above:  <pre><code>// Code generated by Wire protocol buffer compiler, do not edit.\n// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto\npackage com.squareup.dinosaurs\n\nimport com.squareup.geology.Period\nimport com.squareup.wire.FieldEncoding\nimport com.squareup.wire.Message\nimport com.squareup.wire.ProtoAdapter\nimport com.squareup.wire.ProtoReader\nimport com.squareup.wire.ProtoWriter\nimport com.squareup.wire.Syntax.PROTO_3\nimport com.squareup.wire.WireField\nimport com.squareup.wire.internal.immutableCopyOf\nimport com.squareup.wire.internal.sanitize\nimport kotlin.Any\nimport kotlin.AssertionError\nimport kotlin.Boolean\nimport kotlin.Deprecated\nimport kotlin.DeprecationLevel\nimport kotlin.Int\nimport kotlin.Long\nimport kotlin.Nothing\nimport kotlin.String\nimport kotlin.collections.List\nimport kotlin.hashCode\nimport kotlin.jvm.JvmField\nimport okio.ByteString\n\nclass Dinosaur(\n  /**\n   * Common name of this dinosaur, like \"Stegosaurus\".\n   */\n  @field:WireField(\n    tag = 1,\n    adapter = \"com.squareup.wire.ProtoAdapter#STRING\",\n    label = WireField.Label.OMIT_IDENTITY\n  )\n  val name: String = \"\",\n  picture_urls: List&lt;String&gt; = emptyList(),\n  @field:WireField(\n    tag = 5,\n    adapter = \"com.squareup.geology.Period#ADAPTER\",\n    label = WireField.Label.OMIT_IDENTITY\n  )\n  val period: Period = Period.CRETACEOUS,\n  unknownFields: ByteString = ByteString.EMPTY\n) : Message&lt;Dinosaur, Nothing&gt;(ADAPTER, unknownFields) {\n  /**\n   * URLs with images of this dinosaur.\n   */\n  @field:WireField(\n    tag = 2,\n    adapter = \"com.squareup.wire.ProtoAdapter#STRING\",\n    label = WireField.Label.REPEATED,\n    jsonName = \"pictureUrls\"\n  )\n  val picture_urls: List&lt;String&gt; = immutableCopyOf(\"picture_urls\", picture_urls)\n\n  @Deprecated(\n    message = \"Shouldn't be used in Kotlin\",\n    level = DeprecationLevel.HIDDEN\n  )\n  override fun newBuilder(): Nothing = throw AssertionError()\n\n  override fun equals(other: Any?): Boolean {\n    if (other === this) return true\n    if (other !is Dinosaur) return false\n    if (unknownFields != other.unknownFields) return false\n    if (name != other.name) return false\n    if (picture_urls != other.picture_urls) return false\n    if (period != other.period) return false\n    return true\n  }\n\n  override fun hashCode(): Int {\n    var result = super.hashCode\n    if (result == 0) {\n      result = unknownFields.hashCode()\n      result = result * 37 + name.hashCode()\n      result = result * 37 + picture_urls.hashCode()\n      result = result * 37 + period.hashCode()\n      super.hashCode = result\n    }\n    return result\n  }\n\n  override fun toString(): String {\n    val result = mutableListOf&lt;String&gt;()\n    result += \"\"\"name=${sanitize(name)}\"\"\"\n    if (picture_urls.isNotEmpty()) result += \"\"\"picture_urls=${sanitize(picture_urls)}\"\"\"\n    result += \"\"\"period=$period\"\"\"\n    return result.joinToString(prefix = \"Dinosaur{\", separator = \", \", postfix = \"}\")\n  }\n\n  fun copy(\n    name: String = this.name,\n    picture_urls: List&lt;String&gt; = this.picture_urls,\n    period: Period = this.period,\n    unknownFields: ByteString = this.unknownFields\n  ): Dinosaur = Dinosaur(name, picture_urls, period, unknownFields)\n\n  companion object {\n    @JvmField\n    val ADAPTER: ProtoAdapter&lt;Dinosaur&gt; = object : ProtoAdapter&lt;Dinosaur&gt;(\n      FieldEncoding.LENGTH_DELIMITED,\n      Dinosaur::class,\n      \"type.googleapis.com/squareup.dinosaurs.Dinosaur\",\n      PROTO_3,\n      null\n    ) {\n      override fun encodedSize(value: Dinosaur): Int {\n        var size = value.unknownFields.size\n        if (value.name != \"\") size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)\n        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(2, value.picture_urls)\n        if (value.period != Period.CRETACEOUS) size += Period.ADAPTER.encodedSizeWithTag(5,\n            value.period)\n        return size\n      }\n\n      override fun encode(writer: ProtoWriter, value: Dinosaur) {\n        if (value.name != \"\") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name)\n        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 2, value.picture_urls)\n        if (value.period != Period.CRETACEOUS) Period.ADAPTER.encodeWithTag(writer, 5, value.period)\n        writer.writeBytes(value.unknownFields)\n      }\n\n      override fun decode(reader: ProtoReader): Dinosaur {\n        var name: String = \"\"\n        val picture_urls = mutableListOf&lt;String&gt;()\n        var period: Period = Period.CRETACEOUS\n        val unknownFields = reader.forEachTag { tag -&gt;\n          when (tag) {\n            1 -&gt; name = ProtoAdapter.STRING.decode(reader)\n            2 -&gt; picture_urls.add(ProtoAdapter.STRING.decode(reader))\n            5 -&gt; try {\n              period = Period.ADAPTER.decode(reader)\n            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {\n              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())\n            }\n            else -&gt; reader.readUnknownField(tag)\n          }\n        }\n        return Dinosaur(\n          name = name,\n          picture_urls = picture_urls,\n          period = period,\n          unknownFields = unknownFields\n        )\n      }\n\n      override fun redact(value: Dinosaur): Dinosaur = value.copy(\n        unknownFields = ByteString.EMPTY\n      )\n    }\n\n    private const val serialVersionUID: Long = 0L\n  }\n}\n</code></pre>  Creating and accessing proto models is easy:  <pre><code>val stegosaurus = Dinosaur(\n    name = \"Stegosaurus\",\n    period = Period.JURASSIC\n)\n\nprintln(\"My favorite dinosaur existed in the ${stegosaurus.period} period.\")\n</code></pre>  Here's how you can modify the object to add extra fields:  <pre><code>val stegosaurus = stegosaurus.copy(\n    picture_urls = listOf(\"https://www.flickr.com/photos/tags/Stegosaurus/\")\n)\n\nprintln(\"Here are some photos of ${stegosaurus.name}: ${stegosaurus.picture_urls}\")\n</code></pre>"},{"location":"#wire-swift","title":"Wire Swift","text":"<p>Since version 3.3.0, Wire can generate Swift code. See Wire Compiler &amp; Gradle Plugin to learn how to configure your build.</p> <p>Swift support is considered a \u201cbeta\u201d and may still feature breaking changes. That being said, Block is shipping it in production apps and SDKs.</p> <p>Swift is a pragmatic and expressive programming language with rich support for value types. Here\u2019s how we used Swift to model Protocol Buffers messages:</p> <ul> <li>Messages are structs that conform to <code>Equatable</code>, <code>Codable</code> and <code>Sendable</code>. All Messages have value semantics.</li> <li>Fields are generated as properties.</li> <li>The nullability of each field\u2019s type depends on its label: <code>required</code>, <code>repeated</code> and <code>map</code>   fields get non-nullable types, whereas <code>optional</code> fields are of nullable types.</li> </ul> Generated Swift Code  Here's the compact [generated code][dinosaur_swift] for the `Dinosaur` message defined above:  <pre><code>// Code generated by Wire protocol buffer compiler, do not edit.\n// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto\nimport Foundation\nimport Wire\n\npublic struct Dinosaur {\n\n    /**\n     * Common name of this dinosaur, like \"Stegosaurus\".\n     */\n    @ProtoDefaulted\n    public var name: String?\n    /**\n     * URLs with images of this dinosaur.\n     */\n    public var picture_urls: [String] = []\n    @ProtoDefaulted\n    public var length_meters: Double?\n    @ProtoDefaulted\n    public var mass_kilograms: Double?\n    public var period: Period?\n    public var unknownFields: Foundation.Data = .init()\n\n    public init(configure: (inout Self) -&gt; Swift.Void = { _ in }) {\n        configure(&amp;self)\n    }\n\n}\n\n#if !WIRE_REMOVE_EQUATABLE\nextension Dinosaur : Equatable {\n}\n#endif\n\n#if !WIRE_REMOVE_HASHABLE\nextension Dinosaur : Hashable {\n}\n#endif\n\nextension Dinosaur : Sendable {\n}\n\nextension Dinosaur : ProtoDefaultedValue {\n\n    public static var defaultedValue: Dinosaur {\n        Dinosaur()\n    }\n}\n\nextension Dinosaur : ProtoMessage {\n\n    public static func protoMessageTypeURL() -&gt; String {\n        return \"type.googleapis.com/squareup.dinosaurs.Dinosaur\"\n    }\n\n}\n\nextension Dinosaur : Proto2Codable {\n\n    public init(from protoReader: ProtoReader) throws {\n        var name: String? = nil\n        var picture_urls: [String] = []\n        var length_meters: Double? = nil\n        var mass_kilograms: Double? = nil\n        var period: Period? = nil\n\n        let token = try protoReader.beginMessage()\n        while let tag = try protoReader.nextTag(token: token) {\n            switch tag {\n            case 1: name = try protoReader.decode(String.self)\n            case 2: try protoReader.decode(into: &amp;picture_urls)\n            case 3: length_meters = try protoReader.decode(Double.self)\n            case 4: mass_kilograms = try protoReader.decode(Double.self)\n            case 5: period = try protoReader.decode(Period.self)\n            default: try protoReader.readUnknownField(tag: tag)\n            }\n        }\n        self.unknownFields = try protoReader.endMessage(token: token)\n\n        self._name.wrappedValue = name\n        self.picture_urls = picture_urls\n        self._length_meters.wrappedValue = length_meters\n        self._mass_kilograms.wrappedValue = mass_kilograms\n        self.period = period\n    }\n\n    public func encode(to protoWriter: ProtoWriter) throws {\n        try protoWriter.encode(tag: 1, value: self.name)\n        try protoWriter.encode(tag: 2, value: self.picture_urls)\n        try protoWriter.encode(tag: 3, value: self.length_meters)\n        try protoWriter.encode(tag: 4, value: self.mass_kilograms)\n        try protoWriter.encode(tag: 5, value: self.period)\n        try protoWriter.writeUnknownFields(unknownFields)\n    }\n\n}\n\n#if !WIRE_REMOVE_CODABLE\nextension Dinosaur : Codable {\n\n    public init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)\n        self._name.wrappedValue = try container.decodeIfPresent(String.self, forKey: \"name\")\n        self.picture_urls = try container.decodeProtoArray(String.self, firstOfKeys: \"pictureUrls\", \"picture_urls\")\n        self._length_meters.wrappedValue = try container.decodeIfPresent(Double.self, firstOfKeys: \"lengthMeters\", \"length_meters\")\n        self._mass_kilograms.wrappedValue = try container.decodeIfPresent(Double.self, firstOfKeys: \"massKilograms\", \"mass_kilograms\")\n        self.period = try container.decodeIfPresent(Period.self, forKey: \"period\")\n    }\n\n    public func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)\n        let preferCamelCase = encoder.protoKeyNameEncodingStrategy == .camelCase\n        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include\n\n        try container.encodeIfPresent(self.name, forKey: \"name\")\n        if includeDefaults || !self.picture_urls.isEmpty {\n            try container.encodeProtoArray(self.picture_urls, forKey: preferCamelCase ? \"pictureUrls\" : \"picture_urls\")\n        }\n        try container.encodeIfPresent(self.length_meters, forKey: preferCamelCase ? \"lengthMeters\" : \"length_meters\")\n        try container.encodeIfPresent(self.mass_kilograms, forKey: preferCamelCase ? \"massKilograms\" : \"mass_kilograms\")\n        try container.encodeIfPresent(self.period, forKey: \"period\")\n    }\n\n}\n#endif\n</code></pre>  Creating and accessing proto models is easy:  <pre><code>let stegosaurus = Dinosaur {\n    $0.name = \"Stegosaurus\"\n    $0.period = .JURASSIC\n}\n\nprint(\"My favorite dinosaur existed in the \\(stegosaurus.period) period.\")\n</code></pre>  Here's how you can modify the object to add extra fields:  <pre><code>var stegosaurus = stegosaurus\nstegosaurus.picture_urls = [\"https://www.flickr.com/photos/tags/Stegosaurus/\"]\n\nprint(\"Here are some photos of \\(stegosaurus.name): \\(stegosaurus.picture_urls)\")\n</code></pre>"},{"location":"#wire-grpc","title":"Wire gRPC","text":"<p>Since version 3.0.0, Wire supports gRPC.</p>"},{"location":"#generating-code-with-wire","title":"Generating Code With Wire","text":"<p>Wire can read <code>.proto</code> files from the local file system and from within <code>.jar</code> files.</p> <p>The compiler can optionally prune your schema to a subset of root types and their transitive dependencies. This is useful when sharing a schema between projects: a Java service and Android app may each use a subset of a larger shared schema.</p> <p>For more info on how to get started, see Wire Compiler &amp; Gradle Plugin.</p> <p>If you don\u2019t use Gradle, the compiler also has a command line interface. Just substitute <code>wire-compiler-VERSION-jar-with-dependencies.jar</code> with the path to your jar. Download the latest precompiled jar.</p> <pre><code>% java -jar wire-compiler-VERSION-jar-with-dependencies.jar \\\n    --proto_path=src/main/proto \\\n    --java_out=out \\\n    squareup/dinosaurs/dinosaur.proto \\\n    squareup/geology/period.proto\nWriting com.squareup.dinosaurs.Dinosaur to out\nWriting com.squareup.geology.Period to out\n</code></pre> <p>Supplying the <code>--android</code> flag to the compiler causes Wire messages to implement <code>Parcelable</code>.</p> <p>If you use Proguard, then you need to add <code>keep</code> rules.  The simplest option is to tell Proguard not to touch the Wire runtime library and your generated protocol buffers (of course these simple rules will miss opportunities to shrink and optimize the code):</p> <pre><code>-keep class com.squareup.wire.** { *; }\n-keep class com.yourcompany.yourgeneratedcode.** { *; }\n</code></pre>"},{"location":"#get-wire","title":"Get Wire","text":"<p>The <code>wire-runtime</code> package contains runtime support libraries that must be included in applications that use Wire-generated code.</p> <p>With Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.squareup.wire&lt;/groupId&gt;\n  &lt;artifactId&gt;wire-runtime-jvm&lt;/artifactId&gt;\n  &lt;version&gt;4.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>With Gradle:</p> <pre><code>api \"com.squareup.wire:wire-runtime:4.9.2\"\n</code></pre> <p>Snapshots of the development version are available in the Central Portal Snapshots repository.</p>"},{"location":"#unsupported","title":"Unsupported","text":"<p>Wire does not support:</p> <ul> <li>Groups - they are skipped when parsing binary input data</li> </ul> <p>Wire supports custom options on messages and fields. Other custom options are ignored. Pass <code>--excludes=google.protobuf.*</code> to the compiler to omit options from the generated code.</p>"},{"location":"#further-documentation","title":"Further Documentation","text":"<p>See Google\u2019s excellent documentation on the structure and syntax of proto schemas.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#version-540","title":"Version 5.4.0","text":"<p>2025-09-02</p>"},{"location":"changelog/#gradle-plugin","title":"Gradle plugin","text":"<ul> <li>Support <code>android.builtInKotlin=true</code> and experimental plugin (#3367 by Omar Ismail)</li> </ul>"},{"location":"changelog/#version-5311","title":"Version 5.3.11","text":"<p>2025-08-18</p>"},{"location":"changelog/#swift","title":"Swift","text":"<ul> <li>Fix a naming collision if a oneof is called <code>container</code> (#3364 by John Szumski)</li> </ul>"},{"location":"changelog/#version-5310","title":"Version 5.3.10","text":"<p>2025-08-13</p>"},{"location":"changelog/#swift_1","title":"Swift","text":"<ul> <li>Breaking: revert \u201cmark generated enums with <code>@objc</code>\u201d (#3361 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#version-538-539","title":"Version 5.3.8 / 5.3.9","text":"<p>2025-08-08</p>"},{"location":"changelog/#swift_2","title":"Swift","text":"<ul> <li>Fix edge case for oneof field named <code>self</code> (#3360 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#version-537","title":"Version 5.3.7","text":"<p>2025-08-07</p>"},{"location":"changelog/#swift_3","title":"Swift","text":"<ul> <li>Correctly disambiguate types that exist across multiple modules (#3358 by Dimitris Koutsogiorgas)</li> <li>Improve performance of topological sort algorithm for partitions (#3359 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#version-536","title":"Version 5.3.6","text":"<p>2025-08-05</p>"},{"location":"changelog/#cli","title":"CLI","text":"<ul> <li>New CLI option <code>--ignore_unused_roots_and_prunes</code> (#3354)</li> </ul>"},{"location":"changelog/#jvm","title":"JVM","text":"<ul> <li>Fix: Handle negative hexadecimal in default values (#3355)</li> <li>Optimization: Avoid copying of repeated and map types when mutableTypes are being used (#3352 by Rahul Ravikumar)</li> </ul>"},{"location":"changelog/#swift_4","title":"Swift","text":"<ul> <li>Fix: Properly disambiguate OneOf enum if it has the same name as enclosing type (#3350 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#version-535","title":"Version 5.3.5","text":"<p>2025-07-09</p>"},{"location":"changelog/#grpc-client","title":"gRPC Client","text":"<ul> <li>Fix: use correct class loader for clients and builder (#3347 by Stuart Douglas)</li> </ul>"},{"location":"changelog/#version-534","title":"Version 5.3.4","text":"<p>2025-07-08</p>"},{"location":"changelog/#common","title":"Common","text":"<ul> <li>In-development snapshots are now published to the Central Portal Snapshots repository at https://central.sonatype.com/repository/maven-snapshots/.</li> </ul>"},{"location":"changelog/#wire-compiler","title":"Wire Compiler","text":"<ul> <li>Add Kotlin enum mode as a compiler arg (#3339 by Justin Bisignano)</li> </ul>"},{"location":"changelog/#swift_5","title":"Swift","text":"<ul> <li>Mark generated enums with @objc (#3190 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#version-533","title":"Version 5.3.3","text":"<p>2025-06-05</p>"},{"location":"changelog/#gradle-plugin_1","title":"Gradle plugin","text":"<ul> <li>Support for Gradle <code>14.1</code> which fixed a bug (#3303) introduced in Wire <code>5.3.0</code> when we removed internal Gradle APIs (#3293)</li> </ul>"},{"location":"changelog/#version-532","title":"Version 5.3.2","text":"<p>2025-06-03</p>"},{"location":"changelog/#common_1","title":"Common","text":"<ul> <li>Adding wasm target to wire runtime (#3304 by Michael Pawliszyn)</li> <li>Fix crash when inlined option map values have multiple fields (#3314 by Tejas Gupta)</li> </ul>"},{"location":"changelog/#gradle-plugin_2","title":"Gradle plugin","text":"<ul> <li>Update InputLocation to be more cache-friendly (#3313 by Kartikaya Gupta)</li> </ul>"},{"location":"changelog/#java","title":"Java","text":"<ul> <li>Include oneOfs in <code>constructorTakesAllFields()</code> and fix null check in <code>generateOptionType</code> (#3310 by Bruno Freitas)</li> </ul>"},{"location":"changelog/#version-531","title":"Version 5.3.1","text":"<p>2025-03-05</p>"},{"location":"changelog/#gradle-plugin_3","title":"Gradle plugin","text":"<ul> <li>Better remote cache support (#3295)</li> <li>Avoid eagerly resolving the configuration (#3302 by Kartikaya Gupta)</li> </ul>"},{"location":"changelog/#version-530","title":"Version 5.3.0","text":"<p>2025-02-14</p>"},{"location":"changelog/#common_2","title":"Common","text":"<ul> <li>Add support for weak imports in ProtoParser and ProtoFileElement (#3247 by paul35621)</li> <li>Add Gradle and CLI options to load the protobuf schema exhaustively (#3254 by Damian Wieczorek)</li> </ul>"},{"location":"changelog/#swift_6","title":"Swift","text":"<ul> <li>Fix conformance to ProtoMessage for heap allocated protos (#3260 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#gradle-plugin_4","title":"Gradle plugin","text":"<ul> <li>Removed usage of internal Gradle APIs in the Wire Gradle plugin which were crashing in Gradle <code>8.13</code>.</li> </ul>"},{"location":"changelog/#version-521","title":"Version 5.2.1","text":"<p>2025-01-07</p>"},{"location":"changelog/#jvm-generation","title":"JVM generation","text":"<ul> <li>Fix support for mutable messages in Wire\u2019s Kotlin Generator. (#3233 by Rahul Ravikumar)</li> </ul>"},{"location":"changelog/#version-520","title":"Version 5.2.0","text":"<p>2025-01-06</p>"},{"location":"changelog/#common_3","title":"Common","text":"<ul> <li>Enforce recursion limit when parsing nested groups. (#3119)</li> </ul>"},{"location":"changelog/#cli-wire-compiler","title":"CLI <code>wire-compiler</code>","text":"<ul> <li>It is now possible to set multiple targets. (#3106 &amp; #3107)</li> <li>The option <code>opaque_types</code> introduced in <code>4.9.2</code> for the Wire Gradle plugin is now available on CLI. (#3147)</li> </ul>"},{"location":"changelog/#jvm-generation_1","title":"JVM generation","text":"<ul> <li>KotlinPoet has been updated to <code>2.0.0</code> which dramatically changes how generated Kotlin files are wrapped. This is neither a source nor a binary breaking changes.</li> <li>A new <code>@WireEnclosingType</code> annotation is now applied to generated types so R8 doesn\u2019t prune too much. (#3123)</li> <li>Split the redact method into chunks when a type has more than 100 fields to avoid compilation error. (#3214 by Damian Wieczorek)</li> <li>Add support for mutable messages in Wire\u2019s Kotlin Generator. (#3217 by Rahul Ravikumar)</li> <li>You can opt-in by adding <code>mutableTypes = true</code> on your Kotlin target. This is unsafe and we do not recommend that you use it unless you have a sound use-case for it.</li> <li>Wire is now using Palantir\u2019s JavaPoet instead of Square\u2019s JavaPoet.</li> </ul>"},{"location":"changelog/#swift_7","title":"Swift","text":"<ul> <li>Fix buffer overflow and data corruption when a type has more than 5 layers of nesting (#3203 by Eric Amorde)</li> </ul>"},{"location":"changelog/#version-4911","title":"Version 4.9.11","text":"<p>2024-10-09</p>"},{"location":"changelog/#common_4","title":"Common","text":"<ul> <li>Fix Gradle project isolation issue when reading a property (#3078 by Aurimas)</li> </ul>"},{"location":"changelog/#version-510","title":"Version 5.1.0","text":"<p>2024-09-11</p>"},{"location":"changelog/#common_5","title":"Common","text":"<ul> <li>Support for Kotlin <code>2.0.20</code>. (#3093)</li> <li><code>srcDir(String)</code> has been undeprecated. (#3039)</li> <li>Some loggings now happen at the debug level, instead of info. (#3041)</li> <li>Remove some unactionable warnings on Kotlin/JS (#3047)</li> <li>Propagate the deprecated flag on EnumType after pruning by wire-gradle-plugin (#3076 by Aaron Edwards)</li> <li>Introduce <code>ProtoReader32</code>, a specialization for Kotlin/JS (#3077)     This is an alternative to <code>ProtoReader</code>, which uses <code>Long</code> as a cursor. It originates as an optimization for Kotlin/JS, where <code>Long</code> cursors are prohibitively expensive.</li> <li>Fix Gradle project isolation issue when reading a property (#3078 by Aurimas)</li> <li>Change the recursion limit to match grpc\u2019s default (#3091)</li> </ul>"},{"location":"changelog/#kotlin","title":"Kotlin","text":"<ul> <li>New enum option <code>enum_mode</code> to take precedence over the <code>enumMode</code> option added in <code>5.0.0-alpha02</code>. Use this if you want to migrate your enums granularly. (#2993)</li> <li>Don\u2019t throw if reading trailers fail (#3087)</li> </ul>"},{"location":"changelog/#swift_8","title":"Swift","text":"<ul> <li>Avoid crash when parsing an empty repeated <code>[packed=true]</code> for fixed-length types. (#3044 by Sasha Weiss)</li> </ul>"},{"location":"changelog/#version-500","title":"Version 5.0.0","text":"<p>2024-07-15</p>"},{"location":"changelog/#common_6","title":"Common","text":"<ul> <li>Prevent conflicts for options of different types but with similar names (#3005)</li> <li>Support all Gradle entries for file collections (#2946)</li> <li><code>srcDir(String)</code> has been deprecated in favor of <code>srcDir(Any)</code> which better leverages Gradle to   handle dependencies.</li> </ul>"},{"location":"changelog/#version-500-alpha04","title":"Version 5.0.0-alpha04","text":"<p>2024-06-21</p>"},{"location":"changelog/#common_7","title":"Common","text":"<ul> <li>Don\u2019t crash with inlined map options (#2997)</li> </ul>"},{"location":"changelog/#swift_9","title":"Swift","text":"<ul> <li>Escape <code>error</code> names in some cases (#2999 by Adam Lickel)</li> </ul>"},{"location":"changelog/#version-500-alpha03","title":"Version 5.0.0-alpha03","text":"<p>2024-06-19</p>"},{"location":"changelog/#json","title":"JSON","text":"<ul> <li>A performance degradation in JSON serialization was added in the previous <code>5.0.0</code> alphas. This   change has been reverted.</li> </ul>"},{"location":"changelog/#version-500-alpha02","title":"Version 5.0.0-alpha02","text":"<p>2024-06-17</p>"},{"location":"changelog/#common_8","title":"Common","text":"<ul> <li>\u26a0 Paths and Definitions are properly claims by a SchemaHandler only when it generated something (#2943)</li> <li>No eager source access on Task for the Wire Gradle plugin (#2923)</li> <li>Fix the UTF-32 BOM in SchemaLoader (#2937 by Endeavour233)</li> <li>Add support for parsing extensionRangeOptions (#2966)</li> </ul>"},{"location":"changelog/#kotlin_1","title":"Kotlin","text":"<ul> <li>expose the grpc url when converting Response to GrpcException (#2920 by Travis Johnson)</li> <li>Support very long field names with builders (#2959)</li> <li>New <code>enumMode</code> option added to Kotlin targets in order to generate enum types as sealed classes.   Its value can be either <code>enum_class</code> (default value) or <code>sealed_class</code>. <code>enum_class</code> will generate   enum types as Kotlin enum classes, which is the current behavior. <code>sealed_class</code> will generate enum   types as Kotlin sealed classes, generated each constant of the enum type as data objects. On top of   those constants, the sealed class will contain a <code>Unrecognized</code> data class which will contain the   real decoded value for this enum if the runtime didn\u2019t have any constant matching it. This is the   analogue feature of protoc generating a <code>UNRECOGNIZED(-1)</code> constant for enums on proto3. Note   however that Wire doesn\u2019t limit this option to proto3 enums, this can be used for proto2 enums   too.</li> </ul> <pre><code>wire {\n  kotlin {\n    enumMode = \"sealed_class\"\n  }\n}\n</code></pre> <p>Switching to generating sealed class for enums can break the call-site for your consumers. In   order to allow gradual migration of enum generation from/to sealed classes, a Protobuf enum option   has also been created. This, when set in the <code>.proto</code> file, takes precedence over the global enum   mode.</p> <pre><code>import \"wire/extensions.proto\";\n\nenum Period {\n  option (wire.enum_mode) = \"sealed_class\"; // or `enum_class`.\n  CRETACEOUS = 1;\n  JURASSIC = 2;\n  TRIASSIC = 3;\n}\n</code></pre>"},{"location":"changelog/#version-500-alpha01","title":"Version 5.0.0-alpha01","text":"<p>2024-04-16</p>"},{"location":"changelog/#common_9","title":"Common","text":"<ul> <li>\u26a0 Reject unused prunes and roots by default (#2846)     This behavior used to be opt-in, now it\u2019s opt-out. You can opt out with <code>rejectUnusedRootsOrPrunes = false</code>     in your <code>wire { }</code> block.</li> <li>\u26a0 Remove deprecated <code>SchemaHandler#create</code> method (#2851)     Override the other method <code>create(includes, excludes, exclusive, outDirectory, options): SchemaHandler</code> instead if you were not already doing it.</li> <li>\u26a0 Adding a project dependency via <code>srcJar</code> used to work but not anymore. Use <code>srcProject(\":my-project\")</code> instead.</li> <li>Don\u2019t warn about an unused emitting rule, when that rule is \u2018*\u2019 (#2829)</li> <li>The internal of our Wire Gradle plugin has been refactored where behavior changes should not be     expected. If you see anything different, please let us know.</li> <li>Allow custom options to be passed in WireCompiler (#2909)</li> </ul>"},{"location":"changelog/#kotlin_2","title":"Kotlin","text":"<ul> <li>Propagates Request timeout as grpc-timeout (#2840 by Francisco Rojas)</li> <li>Don\u2019t override RealGrpcCall.timeout when it\u2019s manually set (#2893 by Jeff Gulbronson)</li> <li>Publish the gRPC Dispatcher (#2872)     A new helper class GrpcDispatcher for gRPC testing is available under <code>com.squareup.wire:wire-grpc-mockwebserver</code>.     Note that it does not support streaming calls. If you want to contribute, please do!</li> </ul>"},{"location":"changelog/#swift_10","title":"Swift","text":"<ul> <li>\u26a0 Refactored how extensions are emitted and provides a new API to get/set extension fields.     Due to the refactor above, Codable fields that are defined in extensions will now break as part of this change.     All done by Dimitris Koutsogiorgas and Adam Lickel!</li> </ul>"},{"location":"changelog/#wire-grpc-server","title":"wire-grpc-server","text":"<ul> <li>\u26a0 <code>wire-grpc-server</code> has been moved into its own repo: https://github.com/square/wire-grpc-server.     If you were using it, you can see how migration is to happen by checking these instructions.</li> </ul>"},{"location":"changelog/#version-bumps","title":"Version bumps","text":"<ul> <li>kotlin -&gt; <code>1.9.23</code></li> <li>kotlinpoet -&gt; <code>1.16.0</code></li> <li>okhttp -&gt; <code>5.0.0-alpha.12</code></li> <li>okio -&gt; <code>3.9.0</code></li> </ul>"},{"location":"changelog/#version-499","title":"Version 4.9.9","text":"<p>2024-04-02</p>"},{"location":"changelog/#common_10","title":"Common","text":"<ul> <li>Backport JSON serialization for Android SDK below 26 (#2881 by Damian Wieczorek)</li> </ul>"},{"location":"changelog/#version-498","title":"Version 4.9.8","text":"<p>2024-03-18</p>"},{"location":"changelog/#common_11","title":"Common","text":"<ul> <li>Retain imports for types used in maps (#2864)</li> </ul>"},{"location":"changelog/#version-497","title":"Version 4.9.7","text":"<p>2024-02-12</p>"},{"location":"changelog/#common_12","title":"Common","text":"<ul> <li>Support all struct types for JSON encoding (#2824 by Arnaud Frugier)</li> </ul>"},{"location":"changelog/#version-496","title":"Version 4.9.6","text":"<p>2024-02-02</p>"},{"location":"changelog/#common_13","title":"Common","text":"<ul> <li>Add public dependencies when encoding the schema (#2801 by Michael Peyper)</li> </ul>"},{"location":"changelog/#kotlin_3","title":"Kotlin","text":"<ul> <li>Fix RealGrpcCall timeout (#2816 by Jeff Gulbronson)</li> </ul>"},{"location":"changelog/#version-495","title":"Version 4.9.5","text":"<p>2024-01-27</p>"},{"location":"changelog/#common_14","title":"Common","text":"<ul> <li>Fix over pruning imports when only option types are being extended in a file (#2800 by Michael Peyper)</li> </ul>"},{"location":"changelog/#version-494","title":"Version 4.9.4","text":"<p>2024-01-26</p>"},{"location":"changelog/#common_15","title":"Common","text":"<ul> <li>Added <code>linuxArm64</code> target to wire-runtime module (#2733 by Shay Oinif)</li> <li>Add <code>ProtoReader</code> API for length-delimited stream reads (#2747 by Jake Wharton)</li> <li>You can now call <code>ProtoReader#nextLengthDelimited</code> to read and return the length of the next message in a length-delimited stream.</li> <li>Ensure <code>ConsoleWireLogger</code> does not print anything if in quiet mode (#2754 by Dimitris Koutsogiorgas)</li> <li>Provide a built in public <code>EmptyWireLoggerFactory</code> class (#2776 by Dimitris Koutsogiorgas)</li> <li>Stop logging includes and excludes (#2777)</li> <li>Implement equals/hash for Duration and Instant on native and JS (#2781)</li> <li>Prune imports no longer used by retained entities in the schema (#2797 by Michael Peyper)</li> </ul>"},{"location":"changelog/#kotlin_4","title":"Kotlin","text":"<ul> <li>Generate Grpc <code>SERVICE_NAME</code> as const (#2773 by Marius Volkhart)</li> <li>Use <code>%N</code> in <code>KotlinGenerator</code> to ensure names are escaped (#2784 by Egor Andreevich)</li> <li>Add <code>escapeKotlinKeywords</code> parameter to Kotlin target (#2785 by Egor Andreevich)</li> <li>You can now set <code>escapeKotlinKeywords = true</code> within our <code>kotlin {}</code> targets to escape Kotlin keywords with backticks rather than having them suffixed with an <code>_</code>.</li> <li>Don\u2019t retransmit a <code>PipeDuplexRequestBody</code> (#2791)</li> <li>We had crashes that occurred when OkHttp attempted to retry sending the request body of a gRPC streaming connection.</li> </ul>"},{"location":"changelog/#swift_11","title":"Swift","text":"<ul> <li>Remove deprecated cruft (#2721 by Adam Lickel)</li> <li>Always qualify names for types that conflict with common Swift types (#2764 by Dimitris Koutsogiorgas)</li> <li>Fix edge case for heap based messages using a redacted description field (#2772 by Dimitris Koutsogiorgas)</li> <li>Change <code>unknownFields</code> type to <code>[UInt32: Data]</code> from just <code>Data</code>. (#2789 by Dimitris Koutsogiorgas)</li> <li>Introduce a <code>ProtoExtensible</code> protocol that all messages that have been extended conform to. (#2790 by Dimitris Koutsogiorgas)</li> </ul>"},{"location":"changelog/#announcement","title":"Announcement","text":"<p>Wire 5.0 is happening soon. This will happen:</p> <ul> <li><code>SchemaHandler.Factory#create()</code> will be removed. Override its counterpart for painless migration <code>SchemaHandler.Factory#create(includes: List&lt;String&gt;, excludes: List&lt;String&gt;, exclusive: Boolean, outDirectory: String, options: Map&lt;String, String&gt;)</code>.</li> <li>The module <code>wire-grpc-server</code> will be extracted into its own repository: https://github.com/square/wire-grpc-server/</li> <li>Here is how one should migrate: // TODO</li> </ul>"},{"location":"changelog/#version-493","title":"Version 4.9.3","text":"<p>2023-11-23</p> <ul> <li>Breaking: Encoding and decoding of negative <code>Int32</code>s was broken in Swift and did not match protobuf spec.     Negative <code>Int32</code>s are now correctly encoded as unsigned <code>Int64</code>s. Prior versions of Wire that have     serialized a proto containing negative <code>Int32</code> fields will not be correctly decoded using this     version onwards.</li> <li>Fix: Swift <code>ProtoDefaulted</code> was incorrectly applied in cross-module contexts</li> <li>Fix: Message\u2019s Builder won\u2019t break compilation on multiplatform projects.</li> <li>Fix: No hanging anymore on gRPC when receiving an unexpected response.</li> </ul>"},{"location":"changelog/#version-492","title":"Version 4.9.2","text":"<p>2023-11-13</p> <ul> <li>New: Opaque types. You can now specify types you want Wire to evaluate as being of type <code>bytes</code>.     On code generation, the fields of such types will be using the platform equivalent of <code>bytes</code>,     like <code>okio.ByteString</code> for the JVM. Use this if there\u2019s a dependency heavy type which you do     not use. Note that scalar types cannot be opaqued.</li> <li>New: Adds a closure into generate types allowing the creation of an instance via the Kotlin DSL.</li> <li>Fix: Don\u2019t arbitrarily prune <code>oneOf</code> options.</li> <li>Change: Swift <code>Defaulted</code> has been renamed <code>CustomDefaulted</code></li> <li>New: Swift <code>ProtoDefaulted</code> property wrapper and <code>ProtoDefaultedValue</code> protocol</li> <li>Similar to `CustomDefaulted, this adds as projection of the protocol defined default value</li> <li>This should not take up any additional storage</li> <li>This is attached to optional scalar values and messages with entirely optional values</li> <li>New: <code>ProtoDefaulted</code> and <code>CustomDefaulted</code> include setter support</li> <li>This enables you to do something like <code>Foo().$bar.$baz += 1</code></li> <li>Change: Swift <code>ProtoEnum</code> types now have a raw value of <code>Int32</code>.</li> <li>The runtime and generated code both need to be updated to reflect this.</li> </ul>"},{"location":"changelog/#version-491","title":"Version 4.9.1","text":"<p>2023-09-26</p> <ul> <li>Fix: Missing Swift imports.</li> </ul>"},{"location":"changelog/#version-490","title":"Version 4.9.0","text":"<p>2023-09-20</p> <ul> <li>Fix: Swift generates all Storage properties. This mitigates performance issues with dynamicMemberLookup</li> <li>Change: Swift codegen was reordered for readability</li> <li>Change: the type of the Wire option <code>use_array</code> has been changed from <code>string</code> to <code>bool</code>, and its tag has changed from 1180 to 1185.</li> <li>New: Swift propertyWrapper @CopyOnWrite. @Heap is now deprecated and will be removed in November 2024.</li> <li>New: Wildcards are supported when pruning members such as <code>my.namespace.Type#another.namespace.*</code>. This is handy if one wants to prune extension fields.</li> <li>New: Adds warning when one defines a protoLibrary without source sets, which happens on native and JavaScript platforms.</li> <li>New: <code>project(..)</code> dependencies are now explicitly limited to the JVM, for otherwise Wire isn\u2019t able to pick the correct platform to resolve them.</li> <li>New: Wire runtime proto files, such as <code>google/protobuf/descriptor.proto</code> or <code>wire/extensions.proto</code> will not be emitted anymore when <code>protoLibrary = true</code>.</li> <li>New: A custom logger can now be configured via the WireCompiler.</li> <li>New: <code>wire-schema</code>, and <code>wire-schema-tests</code> are now available on JavaScript and native platforms.</li> <li>Update: Okio to <code>3.5.0</code>. All <code>java.nio</code> file systems should now be supported when using Wire.</li> <li>Update: Kotlin to <code>1.9.10</code>, Gradle to <code>8.x</code>, and many others to most recent versions.</li> </ul>"},{"location":"changelog/#version-481","title":"Version 4.8.1","text":"<p>2023-08-17</p> <ul> <li>New: Swift messages now have the form <code>init(REQUIRED FIELDS, (inout Storage) -&gt; Void)</code></li> <li>New: Swift, the member-wise initializer has been removed by default. It can be re-enabled by defining <code>WIRE_INCLUDE_MEMBERWISE_INITIALIZER</code>; however, it will be removed in November 2024. See https://github.com/square/wire/pull/2561 for details</li> <li>Fix: Correctly define sources folders vs. resources folders for Wire generated code.</li> <li>Fix: Generated <code>.proto</code> are correctly added to the built artifact.</li> <li>New: All options of KotlinTarget available on CLI.</li> </ul>"},{"location":"changelog/#version-480","title":"Version 4.8.0","text":"<p>2023-07-21</p> <ul> <li>Fix: JSON to Kotlin deserialization is now really bullet-proofed against   <code>Class.getDeclaredFields</code> random ordering.</li> <li>Fix: proto3 types (<code>Duration</code>, <code>Struct</code>, etc) are now supported when doing dynamic serialization.</li> <li>Fix: <code>GrpcStatus</code> is now serializable which enables <code>GrpcException</code> serialization.</li> <li>New: <code>GrpcClient</code> is now abstract. You can customize how network calls are implemented.</li> <li>New: You can now pass an event listener to receive metric events.</li> <li>New: New option for the Wire Gradle plugin. <code>rejectUnusedRootsOrPrunes = true</code> will fail the build if   any roots or prunes are not used when refactoring the schema. This can help discover incorrect   configurations early and avoid mis-expectations about the built schema.</li> <li>New: <code>OneOf</code>\u2019s options are now loaded to the schema.</li> <li>New: Wire will now fail if it detects a type name collision which can happen if a same file is loaded from different paths.</li> <li>New: <code>wire-schema-tests</code> is now multiplatform.</li> <li>New: <code>SchemaHandler.Factory</code> can now receive payload set within the Wire Gradle plugin. Implement   the method <code>fun create(includes, excludes, exclusive, outDirectory. options): SchemaHandler</code> to receive it.</li> <li>New: custom targets can now pass custom payloads to their <code>SchemaHandler.Factory</code>. The <code>custom {}</code>   takes a map to its new field <code>options</code>. <li>Swift: Default values are now generated via a <code>Defaulted</code> property wrapper.</li> <li>Swift: Fully-qualify <code>Foundation.Data</code> to prevent name collisions with messages named <code>Data</code>.</li> <li>Move: Some types have been moved from <code>wire-compiler</code> to <code>wire-run</code>: <code>WireRun</code>, <code>Target</code>, <code>DirectedAcyclicGraph</code>, <code>PartitionedSchema</code>.</li> <li>Dependency: KotlinPoet has been bumped to <code>1.14.2</code>.</li>"},{"location":"changelog/#version-472","title":"Version 4.7.2","text":"<p>2023-06-18</p> <ul> <li>Swift: Resolve Redactable regression.</li> </ul>"},{"location":"changelog/#version-471","title":"Version 4.7.1","text":"<p>2023-06-16</p> <ul> <li>Swift: Heap types should use <code>DynamicMemberLookup</code> for storage.</li> <li>Fix: Don\u2019t drop the wire_package in a <code>protoPath</code>.</li> <li>Fix: Normalize conflict strategy for boxed <code>oneof</code> field names.</li> <li>Fix: Support all the scalar types in <code>SchemaEncoder</code>.</li> </ul>"},{"location":"changelog/#version-470","title":"Version 4.7.0","text":"<p>2023-05-24</p> <ul> <li>New: Add a dry run option. If enabled, the compiler will just emit the names of the source files that would be   otherwise * generated to stdout. You can use the flag <code>--dry_run</code> with the Wire compiler or define the option with   Gradle as the following:</li> </ul> <p><pre><code>wire {\n  dryRun = true\n}\n</code></pre> * Fix: Correctly set task dependencies on <code>processResources</code> if <code>protoLibrary</code> is set to true. * Fix: If a valid grpc-status header is present, raise a GrpcException rather than an IOException.</p>"},{"location":"changelog/#version-462","title":"Version 4.6.2","text":"<p>2023-05-11</p> <ul> <li>Fix: Explicitly adds <code>jvm</code> variants of multiplatform artifacts into the BOM.</li> <li>Fix: Produce Descriptors for messages without fields after pruning.</li> </ul>"},{"location":"changelog/#version-461","title":"Version 4.6.1","text":"<p>2023-05-10</p> <ul> <li>Fix: Handle length-prefixed messages of length 0.</li> <li>Swift: Bump to <code>1.5</code>.</li> </ul>"},{"location":"changelog/#version-460","title":"Version 4.6.0","text":"<p>2023-05-01</p> <ul> <li>Fix: the version <code>4.5.6</code> had a breaking change which has been reverted in <code>4.6.0</code> without losing   any functionality.</li> <li>Update <code>descriptor.proto</code> from the <code>7dbe742</code> version of <code>protocolbuffers/protobuf</code>.</li> </ul>"},{"location":"changelog/#version-456-note-that-this-holds-a-breaking-change-update-directly-to-460-to-avoid-it","title":"Version 4.5.6 (Note that this holds a breaking change, update directly to <code>4.6.0</code> to avoid it.)","text":"<p>2023-04-25</p> <ul> <li>Fix: JSON serialization is now bullet-proofed against <code>Class.getDeclaredFields</code> random ordering.</li> <li>Perf: Add option <code>wire.use_array</code> to use primitive arrays for packed scalars. This should improve   performances as it avoids autoboxing on the JVM. It will use the appropriate array type, for   example <code>repeated float</code> would be represented as a <code>FloatArray</code>.</li> </ul>"},{"location":"changelog/#version-455","title":"Version 4.5.5","text":"<p>2023-04-12</p> <ul> <li>Perf: Optimize packed scalar list sizes in initial allocation.</li> </ul>"},{"location":"changelog/#version-454","title":"Version 4.5.4","text":"<p>2023-03-31</p> <ul> <li>Kotlin: bump to <code>1.8.20</code>.</li> </ul>"},{"location":"changelog/#version-453","title":"Version 4.5.3","text":"<p>2023-03-23</p> <ul> <li>Swift: fix proto3 messages not always omitting fields with default values.</li> <li>Multiplatform: Builders and their methods are now generated if the configuration requires it.</li> <li>Multiplatform: No more duplicate generations, or wrong tasks naming. Task dependencies are fixed.</li> <li>Multiplatform: Added <code>mingwX64</code> target.</li> <li>Kotlin: bump to <code>1.8.20RC</code>.</li> </ul>"},{"location":"changelog/#version-452","title":"Version 4.5.2","text":"<p>2023-03-06</p> <ul> <li>Fix: Use <code>rawType</code>\u2019s classloader when accessing <code>ProtoAdapter</code>s.</li> <li>gRPC: Decode <code>grpc-status-details-bin</code> and add it to <code>GrpcException</code>.</li> <li>Swift: Fix base64url decoding when string length is a multiple of 4.</li> <li>JSON: Support deserialization of proto3 default param when absent.</li> </ul>"},{"location":"changelog/#version-451","title":"Version 4.5.1","text":"<p>2023-02-11</p> <ul> <li>Fix swift Copy-on-Write behavior.</li> <li>Support deserialization of camelCased fields in proto2.</li> </ul>"},{"location":"changelog/#version-450","title":"Version 4.5.0","text":"<p>2023-02-02</p> <ul> <li>Add support for <code>tvOS</code>.</li> <li>Add ability to supply custom schema handler from command line.</li> </ul>"},{"location":"changelog/#swift_12","title":"Swift","text":"<ul> <li>Add <code>Sendable</code> conformance to all generated types.</li> <li>Improved support for Proto3 types such as <code>Struct</code>, <code>Any</code>, <code>Duration</code>, and <code>Timestamp</code>.</li> <li><code>@JsonString</code> has been deprecated and will be removed in a future release.</li> <li>Codable conformance has been completely rewritten and should be much more compliant to the spec.<ul> <li>This is a somewhat breaking change and heavily dependent upon the types you were using.</li> <li>Notably: Dictionaries with non-string keys are not forwards compatible with new models.</li> <li>The corrected encoding are not backwards compatible with old models.</li> <li>Encoding fixes:<ul> <li><code>unknownFields</code> should never be encoded any more.</li> <li>Don\u2019t encode default values by default (configurable).</li> <li>Encode field names in camelCase by default (configurable).</li> <li>Encode Enums as Strings by default (configurable).</li> <li>Maps will now always encode their keys as Strings.</li> </ul> </li> <li>Decoding fixes:<ul> <li>Data now supports both base64 and base64url binary formats.</li> <li>Enums can now be decoded from either String or UInt32 values.</li> <li>Unknown Enum values can optionally be skipped.</li> <li>Both camelCase and snake_case key names are accepted. camelCase is preferred.</li> </ul> </li> </ul> </li> </ul>"},{"location":"changelog/#version-443","title":"Version 4.4.3","text":"<p>2022-10-26</p> <ul> <li>Fix: No more NPEs when the building project uses Kotlin <code>1.7.20</code>.</li> </ul>"},{"location":"changelog/#version-442","title":"Version 4.4.2","text":"<p>2022-10-06</p> <ul> <li>Fix: Use KotlinProjectExtension to access source sets.</li> <li>Fix: Improve support for ZIP artifacts.</li> <li>Fix: When set to true, <code>buildersOnly</code> will take precedence over <code>javaInterop</code> when generating Kotlin.</li> <li>Fix: Support nested extensions in a message.</li> </ul>"},{"location":"changelog/#version-441","title":"Version 4.4.1","text":"<p>2022-08-05</p> <ul> <li>New: Check HTTP2 protocol is set for passed client to <code>GrpcClient</code>.</li> <li>New: Add buildersOnly option for Java and Kotlin target, setting it to true will change the   visibility of generate types\u2019 constructor to non-public.</li> <li>Fix: Properly define api dependency for <code>okio</code> in <code>wire-schema</code>.</li> <li>Fix: Sort input locations so they match on all platforms.</li> <li>Fix: Avoid NPEs with kotlin <code>1.7.20</code> around source sets.</li> <li>Update: Bumped KotlinPoet to <code>1.12.0</code>.</li> </ul>"},{"location":"changelog/#version-440","title":"Version 4.4.0","text":"<p>2022-06-07</p> <ul> <li>New: Custom schema handlers! Wire lets you now plug in your own logic to deal with the protobuf     schema the way you want. Check our documentation for details. You can     also check our recipe directory for examples.     Note that this API obsoletes the <code>CustomHandlerBeta</code> type Wire had until now.</li> <li>New: You can now easily create an in-memory protobuf schema with the new <code>SchemaBuilder</code> class.     This lives in the new <code>wire-schema-tests</code> artifact. For usage examples, check the tests in     custom handler recipes.</li> <li>Breaking: the <code>wire-profiles</code> artifact has been removed and is now inlined in <code>wire-schema</code>.</li> <li>Breaking: <code>CoreLoader</code> \u2018s <code>isWireRuntimeProto</code> methods are now static.</li> <li>Breaking: <code>SchemaLoader</code> and related classes have been moved from <code>wire-compiler</code> to     <code>wire-schema</code>.</li> <li>New: Support packed and map fields when converting to/from JSON with Kotlin.</li> <li>New: Support typesafe accessors and version catalogs in Wire plugin.</li> <li>New: Generate annotations for repeated options.</li> <li>New: Allow parsing of <code>oneof</code> options.</li> <li>New: Support map fields in options.</li> <li>New: Add macosArm64 support to the KMP projects supporting mac.</li> <li>Fix: Properly deal with maps of scalar types, deserializing missing scala key/value into identity.</li> <li>Fix: Fix a crash where ProtoMember was populated with the wrong data.</li> </ul>"},{"location":"changelog/#version-430","title":"Version 4.3.0","text":"<p>2022-03-24</p> <ul> <li>New: reserved tags and names in enum types are now honoured by Wire.</li> <li>Fix: <code>max</code> keyword is now correctly parsed for enum types.</li> <li>Fix: Wire now writes minus double zeros and minus float zeros on proto3.</li> <li>Fix: Wire doesn\u2019t write google wrappers types\u2019 identity values anymore.</li> <li>Fix: <code>CoreLoader</code> correctly loads <code>.proto</code> files present in the resources of the project.</li> <li>Fix: Propagate <code>GrpcExceptions</code> in <code>GrpcCalls</code>.</li> <li>Fix: Change <code>GrpcCall.isCanceled</code> to honor OkHttp cancellations.</li> </ul>"},{"location":"changelog/#version-420","title":"Version 4.2.0","text":"<p>2022-02-17</p> <ul> <li> <p>New: Publish a bill of materials (BOM) for Wire. Depend on this from Gradle or Maven to    keep all of your Wire artifacts on the same version, even if they\u2019re declared via transitive    dependencies. You can even omit versions when declaring other Wire dependencies.</p> <pre><code>dependencies {\n  implementation(platform(\"com.squareup.wire:wire-bom:4.2.0\"))\n  implementation(\"com.squareup.wire:wire-compiler\")      // No version!\n  implementation(\"com.squareup.wire:wire-gradle-plugin\") // No version!\n  implementation(\"com.squareup.wire:wire-grpc-client\")   // No version!\n  // Etc.\n}\n</code></pre> </li> </ul>"},{"location":"changelog/#version-411","title":"Version 4.1.1","text":"<p>2022-02-15</p> <ul> <li>Fix: Print target name in <code>ConsoleWireLogger</code>.</li> <li>Fix: Throw early when field or constant names start with a digit.</li> <li>Update: Bumped SwiftPoet to <code>1.3.1</code>.</li> <li>Fix: Wire will not generate annotations for <code>repeated</code> options.</li> </ul>"},{"location":"changelog/#version-410","title":"Version 4.1.0","text":"<p>2022-01-28</p> <ul> <li>New: When using Wire JSON factories, you can now override the proto3 behavior of skipping default    values when writing JSON. Set <code>writeIdentityValues</code> to true for either <code>WireJsonAdapterFactory</code>    or <code>WireTypeAdapterFactory</code> to enable it.</li> <li>Breaking: WireLogger methods has been refactored to remove platform dependencies and allow more    precise callbacks. We might add new methods in the future for better logging still.</li> <li>Removal: The <code>dry-run</code> option on <code>WireCompiler</code> has been removed.</li> <li>Swift: WireCompiler podspec is now backup by a jar so consumers will not have to locally build it     on <code>pod install</code>.</li> </ul>"},{"location":"changelog/#version-401","title":"Version 4.0.1","text":"<p>2021-12-07</p> <ul> <li>Fix: Don\u2019t fail at compilation when an enum is in a <code>oneof</code> for Swift generation.</li> </ul>"},{"location":"changelog/#version-400","title":"Version 4.0.0","text":"<p>2021-12-03</p> <ul> <li>New: Add \u2018nameSuffix\u2019 parameter for configuring generated service-class names in Kotlin.</li> <li>New: Define <code>oneofName</code> in <code>@WireField</code>.</li> <li>New: Enable iosSimulatorArm64 for Kotlin multiplatform.</li> <li>New: Expose the source <code>.proto</code> file at <code>ProtoAdaper.sourceFile</code>. This is null for built-in types    and types generated prior to this release.</li> <li>New: Generate Kotlin code whose members match the declaration order of the corresponding <code>.proto</code>    files. In previous releases, generated members were sorted by kind (fields, oneofs), then by    declaration order. With this update only declaration order is used. Note that this will change    the encoded-bytes of these messages. This change is both forwards and backwards-compatible.    Identical encoding of equal messages across Wire releases is typical but not guaranteed, and this    is a rare release that changes that encoding. If you do cryptographic hashes on encoded proto    messages, you will notice that the hashes are different in this release.</li> <li>New: Option in <code>SchemaLoader</code> to exhaustively load imported files. By default we only load what\u2019s    immediately necessary to generate code; this new option loads everything reachable into the    schema.</li> <li>New: Programmatic API to prune schemas. See <code>Pruner</code> in wire-schema.</li> <li>New: SchemaLoader doesn\u2019t extend the <code>Closeable</code> interface anymore.</li> <li>New: Support <code>rpcRole = 'none'</code> in the Gradle plugin to generate neither client nor server code.</li> <li>New: Support for Android variants.</li> <li>New: Support for glob syntax in srcJar includes.</li> <li>New: Support for special float literals.</li> <li>New: Swift support <code>Timestamp</code> and <code>Duration</code>.</li> <li>New: The Wire plugin requires an output to be set. Before, it would generate Java code by    default; it will now throw if there are no output defined.</li> <li>New: The default value of <code>emitAppliedOptions</code> for our Java and Kotlin target is now set to true.</li> <li>New: Wire should build and execute properly on Windows.</li> <li>New: <code>@WireRpc</code> has a new <code>sourceFile</code> attribute.</li> <li>New: <code>GrpcClient.Builder.minMessageToCompress()</code> configures which messages are compressed. This    will completely disable compression if the size is <code>Long.MAX_VALUE</code>. We\u2019ve seen problems where    some Golang gRPC servers don\u2019t support compression; setting this to <code>MAX_VALUE</code> is necessary to    interop with them.</li> <li>New: <code>SchemaReflector</code> is our initial implementation of the    gRPC Server Reflection Protocol. Note that although we implement the business logic of    gRPC reflection, we don\u2019t offer a gRPC server built into Wire.</li> <li>New: <code>wire-reflector</code> bundles gRPC\u2019s <code>reflection.proto</code> which it is built upon.</li> <li>New: <code>wire-runtime</code> exposes a <code>com.squareup.wire.VERSION</code> constant reflecting the project version.</li> <li>New: change the Gradle plugin so that (unstable) custom handlers can be configured with instance    instead of with a class name.</li> <li>Fix: Be more aggressive about loading transitive files with <code>SchemaLoader.loadExhaustively</code>.</li> <li>Fix: Bugs in JSON serialization of builder-less Kotlin types have been addressed.</li> <li>Fix: Compile Kotlin/JS with both LEGACY and IR compilers.</li> <li>Fix: Deep copy metadata on <code>GrpcCall.clone()</code>.</li> <li>Fix: Don\u2019t break task caching by using absolute paths in the Gradle plugin. Wire now uses    project-relative paths in any attribute that is used as a cache key.</li> <li>Fix: Don\u2019t crash encoding schemas when an option contains a repeated field, an enum, or a double.</li> <li>Fix: Don\u2019t depend on moshi-kotlin in wire-moshi. This caused a transitive dependency on    kotlin-reflect, which we neither needed nor wanted.</li> <li>Fix: Don\u2019t generate invalid code when an enum constant is named <code>name</code> or <code>ordinal</code>.</li> <li>Fix: Don\u2019t re-use the cache if protobuf inputs have changed.</li> <li>Fix: Emitting proper protobuf format for option values defined as a list of enum constants.</li> <li>Fix: Explicitly defined Wire gRPC server generation as experimental: the feature isn\u2019t complete.</li> <li>Fix: Generate <code>@Deprecated</code> annotations on deprecated messages, fields, enums, and enum    constants.</li> <li>Fix: Handle out of order proto fields when initializing Kotlin constructors.</li> <li>Fix: Handle writing/reading exceptions for duplex calls in Wire gRPC.</li> <li>Fix: In Java, rename instances to avoid field and class name conflicts.</li> <li>Fix: Locate files in the root package when importing.</li> <li>Fix: Memory fixes found with Address Sanitizer in Swift.</li> <li>Fix: Permit values other than <code>0</code> and <code>1</code> when decoding protobuf-encoded booleans. Previously we    threw an <code>IOException</code> for other values; now all non-zero values are true.</li> <li>Fix: Redact boxed <code>OneOf</code> fields.</li> <li>Fix: Redacted Kotlin scalars now respect nullability.</li> <li>Fix: Retain field order when emitting a schema as <code>.proto</code> files.</li> <li>Fix: Reverse the topological sort of dependent files in <code>SchemaReflector</code>. We had problems with    <code>grpc-curl</code> which expects the requested file to be listed first.</li> <li>Fix: Support Kotlin-generated annotations on Java fields.</li> <li>Fix: Support for serializing builder-less Kotlin generated classes to JSON.</li> <li>Fix: Support reporting errors in <code>CustomHandlerBeta</code>.</li> <li>Fix: Suppress deprecation warnings on generated enum\u2019s <code>fromValue</code> method in Kotlin.</li> <li>Fix: Swift adapters will throw an error when encountering an unexpected    <code>ProtoReader.beginMessage()</code> rather than calling <code>fatalError()</code>.</li> <li>Fix: Update the Wire Gradle plugin to clear the output directory before generating code. This    prevents the need to do a clean build after removing a message type.</li> <li>Fix: Update the Wire Gradle plugin to register generated <code>.java</code> sources with the Java compiler.    Previously this was broken if the Kotlin plugin was installed.</li> <li>Fix: Use Gradle\u2019s logging mechanism to reduce output when Wire generates code.</li> <li>Fix: Use correct type when referencing a custom adapter in Kotlin generated code.</li> <li>Fix: Use relative path sensitivity and file collection.</li> <li>Fix: Validate enum constant uniqueness for the entire package.</li> <li>Fix: Wire Gradle plugin tasks have been modernized with configuration caching support.</li> <li>Fix: Wire will not generate respective built-in types for Java, Kotlin, and Swift generation.    Those are usually the google types for which Wire will provide its own implementation.</li> <li>Upgrade: Update KotlinPoet to <code>1.8.0</code>.</li> <li>Upgrade: OkHttp 4.9.3.</li> <li>Upgrade: Okio 3.0.0. We now use Okio 3\u2019s <code>FileSystem</code> in <code>SchemaLoader</code>, which    makes it easier to load <code>.proto</code> files from the classpath. This is binary-incompatible with the    Okio 3.0 alpha releases.</li> <li>Bye: Drop support for emitKotlinxSerialization.</li> </ul>"},{"location":"changelog/#version-371","title":"Version 3.7.1","text":"<p>2021-11-03</p> <ul> <li>Fix: Properly load schema located at root without packages.</li> </ul>"},{"location":"changelog/#version-370","title":"Version 3.7.0","text":"<p>2021-03-25</p> <ul> <li>New: <code>srcProject(\":project-name\")</code> makes it easier to depend on <code>.proto</code> files of other projects.</li> <li>Fix: Don\u2019t require source that <code>.proto</code> directories exist at Gradle plugin configuration time.    This was preventing Wire from using other tasks\u2019 outputs as its inputs.</li> <li>Fix: Don\u2019t fail if options have a <code>.</code> prefix.</li> </ul>"},{"location":"changelog/#version-361","title":"Version 3.6.1","text":"<p>2021-03-09</p> <ul> <li>Fix: The Wire Gradle plugin now supports Java only Android projects.</li> <li>Fix: In the Wire Gradle plugin, <code>sourcePath</code> will now include only protos defined with <code>include</code>    if the option is present. It used to include all existing <code>.proto</code> files even if <code>include</code> was    used.</li> <li>New: Full support Optional Int64 and UInt64 for JSONString in Swift.</li> </ul>"},{"location":"changelog/#version-360","title":"Version 3.6.0","text":"<p>2021-02-08</p> <ul> <li>New: Automatically add a dependency when a <code>protoPath</code> or <code>protoSource</code> depends on a project.</li> <li>New: <code>protoPath</code> and <code>protoSource</code> dependencies are now not transitive by default.</li> <li>New: New protoLibrary option for the Wire Gradle plugin. Configuring a project as a protoLibrary    will cause the generated <code>.jar</code> file to include <code>.proto</code> sources.</li> <li>New: Code generation for plain gRPC server. The Kotlin target now has a new    <code>grpcServerCompatible</code> option which if set to <code>true</code> will generate gRPC server-compatible    classes.</li> <li>New: Introduce <code>GrpcException</code>.</li> <li>New: Add GrpcMethod tag to the request.</li> <li>New: Adds redacting support for Moshi JSON adapters.</li> <li>New: Publish plugin marker for Gradle plugin.</li> <li>Fix: Escape square brackets in Kotlin generated code documentation.</li> <li>Fix: Improved proto parsing performance.</li> </ul>"},{"location":"changelog/#version-350","title":"Version 3.5.0","text":"<p>2020-10-27</p> <ul> <li>New: Wire Gradle plugin improvements:</li> <li>A task is now created for each available sources (main, Android variants, etc).</li> <li>The <code>wire-runtime</code> dependency is automatically added.</li> <li>Generated code directories are automatically added into their module\u2019s source sets.</li> <li>New: Wire\u2019s proto parser now knows about <code>oneOfOptions</code>.</li> <li>New: Wire will throw when two enum constants are ambiguous, like <code>ZERO</code> and <code>zero</code>.</li> <li>New: Bytes options are not eligible anymore as annotation members.</li> <li>Fix: Optional fields in proto3 are now generated as nullable fields.</li> <li>Fix: JSON camel-casing is updated to fit latest protobuf specifications.</li> <li>Fix: Exception messages when gRPC fails have been improved.</li> <li>Fix: Allow <code>;</code> as entry separator in option maps.</li> <li>Fix: Enum constants are now properly escaped when conflicting with keywords of their generated  target platform.</li> <li>Fix: Update to KotlinPoet 1.7.2 which makes a lot of change in how Kotlin code is generated.</li> </ul>"},{"location":"changelog/#version-340","title":"Version 3.4.0","text":"<p>2020-09-24</p> <ul> <li>New: Stop emitting enum constant options as fields for Kotlin.</li> <li>New: The Wire Gradle plugin task is now cacheable.</li> <li>New: New GrpcCall function to help implement fakes.</li> <li>New: Change GrpcStreamingCall.execute() to support structured concurrency.</li> </ul>"},{"location":"changelog/#version-330","title":"Version 3.3.0","text":"<p>2020-09-14</p> <ul> <li>New: Proto3 support! This includes the new behaviors, the new types, and the JSON.</li> <li>New: Swift support for proto2 schemas. The details are in our blog post.</li> <li>New: Wire will now throw an error when:</li> <li>two generated files end up overriding each other,</li> <li>imports form a cycle,</li> <li>packages form a cycle. This can be turned off with the flag <code>permitPackageCycles</code>,</li> <li>an option within the source set cannot be resolved,</li> <li>there are name duplications of members in a message, or of rpcs in a service,</li> <li>a map is used as an extension.</li> <li>New: Support for the <code>json_name</code> pseudo option.</li> <li>New: The <code>wire_package</code> file option allows one to set the JVM package where classes generated    from the concerned file will be placed. <code>wire_package</code> takes precedence over <code>java_package</code>.</li> <li>New: Lists and maps in Kotlin generated code are now immutable.</li> <li>New: Support UTF-8 with BOM in proto files.</li> <li>New: <code>wire.since</code> and <code>wire.until</code> have been renamed with the prefix <code>constant_</code> for    <code>EnumValueOptions</code>.</li> <li>New: Wire generates 1) annotations for options which 2) gets assigned to the generated code where    appropriate. Both behavior can be turn on or off via the flags:</li> <li><code>emitDeclaredOptions</code>: True to emit types for options declared on messages, fields, etc.      Default to true,</li> <li><code>emitAppliedOptions</code>: True to emit annotations for options applied on messages, fields, etc.      Default to false.</li> <li>Fix: Recursive map values.</li> <li>Fix: Long expressions in equals and encodedSize functions.</li> </ul>"},{"location":"changelog/#version-322","title":"Version 3.2.2","text":"<p>2020-05-15</p> <ul> <li>Fix: JSON serialization correctly emits all values.</li> </ul>"},{"location":"changelog/#version-321","title":"Version 3.2.1","text":"<p>2020-05-02</p> <ul> <li>New: <code>onlyVersion</code> option on the Wire Gradle plugin to target a unique version. By and large,    service code that supports many clients would target ranges via <code>sinceVersion</code> and    <code>untilVersion</code>, while client code would target a unique version via <code>onlyVersion</code>.</li> <li>New: Support for optional fields in Proto3.</li> <li>Fix: Restored the <code>GrpcClient.create</code> API to create implementations for gRPC interfaces.</li> </ul>"},{"location":"changelog/#version-320","title":"Version 3.2.0","text":"<p>2020-04-23</p> <ul> <li>New: <code>wire.since</code> and <code>wire.until</code> options on members and enum values. You can prune fields or    constants using these two options. When generating code with the Wire Gradle plugin, define    <code>sinceVersion</code> and/or <code>untilVersion</code> to scope the generated code.</li> <li>New: Messages\u2019 <code>toString</code> method on Kotlin and Java now escape string values for easy parsing.</li> <li>Fix: Link the entire <code>descriptor.proto</code> every time when building the <code>Schema</code>.</li> <li>Fix: Properly handle members named after keywords of the target language for both Java and    Kotlin.</li> <li>Fix: Use the declared name for keys in JSON when emitting/reading keyword named members.</li> <li>Fix: Generated Kotlin code is malformed for long identifiers.</li> <li>Fix: Make the Wire Gradle plugin compatible with instant execution.</li> </ul>"},{"location":"changelog/#version-310","title":"Version 3.1.0","text":"<p>2020-02-06</p> <p>This release includes major non-backwards-compatible API changes to the <code>wire-schema</code> module. This will break tools that use Wire\u2019s schema modeling as a standalone library. We are making big changes to this component and we sacrificed API compatibility to accelerate these improvements.</p> <ul> <li>New: <code>proto { ... }</code> target in the Wire Gradle plugin. Use this to perform basic source code    transformations on collections of <code>.proto</code> files. We use it to prune large collections of protos    to just the subset used by the application.</li> <li>Fix: Support all forms of reserved extensions, such as <code>extensions 1, 3 to 5, 7;</code>.</li> <li>Fix: Don\u2019t re-generate source files when their <code>.proto</code> files haven\u2019t changed.</li> <li>New: <code>includes</code>, <code>excludes</code>, <code>root</code>, and <code>prune</code> give precedence to the most precise rule.    Previously <code>excludes</code> always took precedence over <code>includes</code>, and <code>prune</code> always took precedence    over <code>root</code>.</li> <li>Fix: Generate non-instantiable class for enclosing types in Kotlin. These are emitted when a    nested type is retained but its enclosing type is pruned.</li> <li>Fix: Do not fail to build when the profile cannot find a dependency.</li> </ul>"},{"location":"changelog/#version-303","title":"Version 3.0.3","text":"<p>2019-12-23</p> <p>Starting with this version the Wire Maven plugin is no longer maintained and has been removed from the repository.</p> <ul> <li>New: Support for custom options in Kotlin.</li> <li>New: Kotlin 1.3.61.</li> <li>New: Add support for custom targets in <code>WireRun</code> and the Gradle plugin.</li> <li>New: Improve schema evaluation algorithm when loading separate <code>sourcePath</code> and <code>protoPath</code>.</li> <li>New: Lazy loading of <code>protoPath</code> contents.</li> <li>New: Make it possible to customize Gradle plugin\u2019s configurations.</li> <li>New: Make it possible to customize Gradle plugin\u2019s <code>generateProtos</code> task.</li> <li>Fix: Use correct <code>ProtoAdapter</code> for packed fields in Kotlin.</li> <li>Fix: Properly handle name clashes between fields and enclosing types.</li> <li>Fix: Preserve the package name on files loaded from <code>protoPath</code>.</li> <li>Fix: ProtoPruner: Properly evaluate Pruner\u2019s reachable objects.</li> <li>Fix: ProtoPruner: Ensure <code>--excludes</code> properly prunes options.</li> <li>Fix: ProtoPruner: Keep used <code>ServiceOptions</code> and <code>MethodOptions</code> when pruning.</li> </ul>"},{"location":"changelog/#version-302","title":"Version 3.0.2","text":"<p>2019-11-22</p> <ul> <li>Fix: Generate correct unknownFields code if a message field\u2019s name is a Kotlin keyword.</li> <li>Fix: Properly handle unknown enum values in Kotlin.</li> <li>Fix: ProtoPruner: retain used extends.</li> <li>Fix: ProtoPruner: retain only used imports.</li> <li>Fix: ProtoPruner: use NewSchemaLoader that correctly loads google.protobuf.descriptor.</li> <li>Fix: ProtoPruner: print default values for scalar types for proto target within the options.</li> <li>Fix: ProtoPruner: fix handling of options.</li> <li>Fix: ProtoPruner: print default values for enums.</li> </ul>"},{"location":"changelog/#version-301","title":"Version 3.0.1","text":"<p>2019-10-18</p> <ul> <li>Fix: Use the correct adapter path for gRPC endpoints that customize the Java package.</li> <li>Fix: Preserve documentation in generated services.</li> <li>Fix: Fail to generate code if the source directory doesn\u2019t exist.</li> <li>Fix: Make Kotlin consistent with Java for unknown enum constants. We now treat these as unknown    fields rather than failing to decode the enclosing message.</li> </ul>"},{"location":"changelog/#version-300","title":"Version 3.0.0","text":"<p>2019-10-07</p> <ul> <li>Update: All gRPC networking calls are encoded in gzip.</li> </ul>"},{"location":"changelog/#version-300-rc03","title":"Version 3.0.0-rc03","text":"<p>2019-10-04</p> <ul> <li>Fix: Update dependency to a stable version, <code>2.4.1</code> of Okio.</li> </ul>"},{"location":"changelog/#version-300-rc02","title":"Version 3.0.0-rc02","text":"<p>2019-10-01</p>"},{"location":"changelog/#kotlin_5","title":"Kotlin","text":"<ul> <li>Fix: Nullify other oneof fields in Builder setters in Kotlin interop.</li> <li>Fix: Use unknownFields in <code>hashCode()</code>.</li> <li>Fix: Remove <code>withoutUnknownFields()</code> from Kotlin.</li> </ul>"},{"location":"changelog/#grpc","title":"gRPC","text":"<ul> <li>Update: Total rewrite of the generated interfaces for clients:</li> </ul> <p>Introduce two interfaces, <code>GrpcCall</code> for simple RPCs, and <code>GrpcStreamingCall</code> fox duplex ones. Both    will provide blocking and suspending API, including a reference to the underlying    OkHttp Call object and its timeout.</p> <ul> <li>Fix: Send stream cancels from clients.</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>New: Changes printing of options and enums:</li> <li>No empty lines between options and fields for enums.</li> <li>Print options on new lines only when more than one.</li> <li>Fix: Don\u2019t cache Message\u2019s hash code on Native.</li> <li>Fix: Fix handling of map values in <code>FieldBinding</code>.</li> <li>Fix: Fix import fails on windows due to path separator.</li> <li>Fix: Don\u2019t emit proto2 sources for proto3 syntax.</li> </ul>"},{"location":"changelog/#version-300-rc01","title":"Version 3.0.0-rc01","text":"<p>2019-08-02</p>"},{"location":"changelog/#compiler-gradle-plugin","title":"Compiler + Gradle plugin","text":"<ul> <li>New: Support includes on Maven coordinate dependencies.</li> <li>New: Track includes separately for source vs proto paths.</li> <li>New: Follow symlinks when building.</li> <li>New: Change the Gradle plugin to track targets as a list.</li> <li>New: Includes and Excludes for Wire targets.</li> <li>New: Print errors on ambiguous and missing imports.</li> <li>Fix: Fix a bug where protopath Maven resources weren\u2019t working.</li> <li>Fix: Don\u2019t reuse source dependencies as protopath dependencies.</li> <li>Fix: Fix <code>equals()</code> implementation for messages with no fields.</li> </ul>"},{"location":"changelog/#kotlin_6","title":"Kotlin","text":"<ul> <li>New: Move Wire.kt into <code>jvmMain</code> to discourage its use in common Kotlin code.</li> <li>New: Make <code>Message.adapter</code> a <code>val</code>.</li> <li>New: Optimize <code>decode()</code> code for protos with no fields.</li> <li>New: Update supported Native platforms.</li> <li>New: Make <code>Message.unknownFields</code> property non-nullable.</li> <li>New: Make <code>Message.unknownFields</code> a <code>val</code>.</li> <li>Fix: Don\u2019t use <code>KClass.simpleName</code> to avoid needing <code>kotlin-reflect</code> dependency.</li> <li>Fix: Use <code>kotlin.UnsupportedOperationException</code> in generated code.</li> </ul>"},{"location":"changelog/#grpc_1","title":"gRPC","text":"<ul> <li>New: Introduce <code>MessageSource</code> and <code>MessageSink</code> interfaces in <code>wire-runtime</code>.</li> <li>New: Honor Java package names in Wire gRPC services.</li> <li>New: Make <code>PipeDuplexRequestBody</code> internal.</li> <li>Fix: Workaround for <code>@Generated</code> annotation on Java 9+.</li> <li>Fix: Fix types for blocking APIs.</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Fix: Fix deserializing null values in Gson adapter.</li> <li>Fix: Change <code>wire-runtime</code> artifact names to preserve 2.x compatibility.</li> </ul>"},{"location":"changelog/#version-300-alpha03","title":"Version 3.0.0-alpha03","text":"<p>2019-06-22</p> <ul> <li>Similar to alpha02, but with proper <code>wire-runtime</code> multiplatform artifacts.</li> </ul>"},{"location":"changelog/#version-300-alpha02","title":"Version 3.0.0-alpha02","text":"<p>2019-06-21</p> <ul> <li>New: Experimental multiplatform runtime.</li> </ul> <p>Starting with this version, <code>wire-runtime</code> is published as a multiplatform Kotlin artifact. While    the JVM artifact is binary- and behavior-compatible with 3.0.0-alpha01, artifacts for other    platforms may not work correctly at this point. The artifact name for the JVM artifact has been    changed to <code>wire-runtime-jvm</code>: now, in order to depend on the multiplatform runtime, use the    following Gradle dependency declaration:</p> <pre><code>api \"com.squareup.wire:wire-runtime:3.0.0-alpha02\"\n</code></pre> <p>and if you want to depend on the JVM artifact only, use the following declaration:</p> <pre><code>api \"com.squareup.wire:wire-runtime-jvm:3.0.0-alpha02\"\n</code></pre> <ul> <li>New: Generate RPCs as Single Abstract Methods.</li> <li>New: Add \u201csingleMethod\u201d Gradle plugin configuration for services.</li> <li>New: Add \u201cblockingServices\u201d Gradle plugin configuration for services.</li> <li>New: Support packageless services code generation.</li> <li>New: Remove sealed classes-based oneof implementation.</li> <li>New: Don\u2019t generate a Builder for non-interop Kotlin messages.</li> <li>Fix: Kotlin Generator correctly generates code for Protobuf services.</li> <li>Fix: Improved formatting of generated Kotlin code.</li> <li>Fix: Generate correct adapter names for WireField annotation.</li> <li>Fix: Generate labels for WireField annotation.</li> <li>Fix: Wrap oneof error message properly.</li> </ul>"},{"location":"changelog/#version-300-alpha01","title":"Version 3.0.0-alpha01","text":"<p>2019-03-14</p> <ul> <li>New: Kotlin Generator</li> </ul> <p>Wire 3 can generate Kotlin data classes. To enable this feature via the command line API, pass in    the <code>--kotlin_out</code> parameter that should specify the output directory for the generated <code>*.kt</code>    files.    Given the following simple proto:</p> <pre><code>message Person {\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n}\n</code></pre> <p>the generated Kotlin code will look like the following:</p> <pre><code>data class Person(\n  @field:WireField(tag = 1, adapter = \"com.squareup.wire.ProtoAdapter#STRING\")\n  val name: String,\n  @field:WireField(tag = 2, adapter = \"com.squareup.wire.ProtoAdapter#INT32\")\n  val id: Int,\n  @field:WireField(tag = 3, adapter = \"com.squareup.wire.ProtoAdapter#STRING\")\n  val email: String? = null,\n  val unknownFields: ByteString = ByteString.EMPTY\n) : Message&lt;Person, Person.Builder&gt;(ADAPTER, unknownFields) {\n  companion object {\n    @JvmField\n    val ADAPTER: ProtoAdapter&lt;Person&gt; = ... // code omitted for brevity\n</code></pre> <p>The <code>copy()</code> method of a data class replaces most usages of the builder. If your code relies on    the <code>Builder</code>, you can enable full <code>Builder</code> generation by passing the <code>--java_interop</code> parameter    to the compiler.</p> <ul> <li>New: gRPC support</li> </ul> <p>In addition to generating Kotlin code from proto messages, Wire can now generate code for gRPC    endpoints. Here\u2019s an example schema:</p> <pre><code>service RouteGuide {\n  // A simple RPC.\n  //\n  // Obtains the feature at a given position.\n  //\n  // A feature with an empty name is returned if there's no feature at the given\n  // position.\n  rpc GetFeature(Point) returns (Feature) {}\n}\n</code></pre> <p>The generated code will look like the following (message protos, referenced by the schema, are    omitted):</p> <pre><code>interface RouteGuide : Service {\n  @WireRpc(\n      path = \"/routeguide.RouteGuide/GetFeature\",\n      requestAdapter = \"routeguide.Point#ADAPTER\",\n      responseAdapter = \"routeguide.Feature#ADAPTER\"\n  )\n  suspend fun GetFeature(request: Point): Feature\n}\n</code></pre> <p>All four gRPC modes are supported: the generated code uses suspendable functions to implement    non-blocking asynchronous execution. In streaming modes, <code>ReceiveChannel</code> and <code>SendChannel</code> are    used to listen to asynchronous data in a non-blocking fashion.</p> <p>This feature works out of the box in Wire 3 compiler as long as the input file contains a gRPC    schema.</p> <ul> <li>New: Gradle plugin</li> </ul> <p>Here\u2019s an example Gradle configuration:</p> <pre><code>apply plugin: 'com.squareup.wire'\n\nwire {\n  // Keeps only 'Dinosaur#name' as the root of the object graph\n  roots 'squareup.dinosaurs.Dinosaur#name'\n\n  // Keeps all fields, except 'name', in 'Dinosaur'\n  prunes 'squareup.dinosaurs.Dinosaur#name'\n\n  // Both roots and prunes in an external file\n  rules 'rules.txt'\n\n  kotlin {\n    javaInterop true\n    out \"${buildDir}/generated/custom\"\n  }\n}\n</code></pre> <p>The <code>wire</code> extension introduces the concept of compilation targets, such as <code>kotlin</code> and <code>java</code>,    where each target has its own configuration properties. Multiple targets can be supplied, which    benefits use cases such as migrating Java protos to Kotlin.</p> <ul> <li>New: Decouple the option of using Android annotations for nullability from the option of having messages implement Parcelable.</li> <li>New: Wire Moshi adapter for serializing proto JSON representation using the Moshi library.</li> <li>New: Implement support for custom enum types.</li> <li>New: Generate AndroidX nullability annotations instead of old support library annotations.</li> <li>New: Import JSR 305 and use it to mark nullability of public API.</li> <li>New: Allow inline multiline comments.</li> <li>New: Generate an empty class when a nested message is retained but its parent was pruned.</li> <li>New: Support rendering a <code>ProtoFile</code> to its schema.</li> <li>New: Support hexadecimal numeric literals.</li> <li>New: Allow custom types to be constrained with a \u2018with\u2019 clause.</li> <li>New: Generate a constructor which takes in a <code>Message.Builder</code> instead of all fields separately.</li> <li>New: Add location to the error message about unsupported group elements.</li> <li>New: Permit single files to be used on the proto path.</li> <li>Fix: Emit \u2018=\u2019 for syntax declaration.</li> <li>Fix: Don\u2019t crash when a comment has a dollar sign.</li> <li>Fix: Return subclass type instead of abstract parameterized type for newBuilder.</li> <li>Fix: Validate enum namespace in file context are unique.</li> </ul>"},{"location":"changelog/#version-220","title":"Version 2.2.0","text":"<p>2016-06-17</p> <ul> <li>New: Support for <code>map</code> type in the schema, compiler, and runtime!</li> <li>New: <code>AndroidMessage</code> base class consolidates everything required for supporting Android and will    now be used for generating code with <code>--android</code>.</li> <li>New: <code>stream</code> keyword in RPC definitions is now parsed and exposed in the schema.</li> <li>Fix: Nested types which are retained no longer cause their enclosing type to be retained. Instead,    non-instantiable empty types will be generated for pruned enclosing types.</li> <li>Fix: Remove per-type <code>Parcelable.Creator</code> classes and instead use a single type which delegates    to the message\u2019s <code>ProtoAdapter</code>.</li> <li>Fix: Retain information on redacted fields even when options were pruned.</li> <li>Fix: Do not generate code for handling <code>null</code> from list types (and now map types) which are    guaranteed to never be <code>null</code>.</li> </ul>"},{"location":"changelog/#version-212","title":"Version 2.1.2","text":"<p>2016-04-15</p> <ul> <li>Fix: Gson type adapter now deserializes JSON null literals to empty list for repeated fields.</li> </ul>"},{"location":"changelog/#version-211","title":"Version 2.1.1","text":"<p>2016-02-01</p> <ul> <li>New: <code>reserved</code> keyword is now supported and enforced.</li> <li>Fix: Defer reflection-based lookup of enum method until first use to avoid    class loading race conditions.</li> <li>Fix: Support single-quoted string literals.</li> <li>Fix: Adjacent string literals are not correctly concatenated.</li> </ul>"},{"location":"changelog/#version-210","title":"Version 2.1.0","text":"<p>2016-01-18</p> <ul> <li>Empty lists of packed values were being encoded incorrectly. In Wire 2.0.x our message    adapters incorrectly included empty lists for <code>[packed=true]</code> rather than omitting them. This is    now fixed.</li> <li>New: <code>Message.encode()</code> to concisely encode a message.</li> <li>New: <code>MessageAdapter.decode(ByteString)</code> to decode a message from a byte string without an    intermediate byte array.</li> <li>New: Wire now includes a sample code generation for service interfaces.</li> </ul>"},{"location":"changelog/#version-203","title":"Version 2.0.3","text":"<p>2016-01-04</p> <ul> <li>New: <code>ProtoAdapter.get</code> overload which returns an adapter given an instance of a message.</li> <li>New: <code>@Nullable</code> annotations are emitted for <code>optional</code> fields when using <code>--android</code>.</li> <li>Fix: Remove the need for <code>javac</code> to generate synthetic accessor methods in the generated code.    This results in smaller code size and less method references (for Android users).</li> </ul>"},{"location":"changelog/#version-202","title":"Version 2.0.2","text":"<p>2015-12-14</p> <ul> <li>Fix: Exclude unknown fields when encoding JSON and drop unknown fields when parsing JSON.</li> <li>Fix: Ensure JSON encoding and decoding works in the default generation mode (not just    <code>--compact</code>) by always adding <code>@WireField</code> metadata to message fields.</li> <li>Fix: Update to JavaPoet 1.4 for more accurate generation of valid Java code.</li> </ul>"},{"location":"changelog/#version-201","title":"Version 2.0.1","text":"<p>2015-11-12</p> <ul> <li>Fix: Do not emit <code>case</code> statements for aliased enum constant values. The first constant for a    value will be returned when deserializing.</li> <li>Fix: Emit <code>@Deprecated</code> annotation on deprecated enum constants.</li> <li>Fix: Correctly prune dependencies of excluded message, enum, or service members. Previously    the dependencies of an excluded member were retained despite the member itself being omitted.</li> </ul>"},{"location":"changelog/#version-200","title":"Version 2.0.0","text":"<p>2015-10-23</p> <p>Wire 2 is a backwards-incompatible release. It makes breaking changes to the compiler, runtime, extensions, and generated code. These changes aren\u2019t made lightly as we\u2019ve endured the upgrade in our own projects! We believe the cost of migration is worth the benefits.</p> <p>We\u2019ve created the <code>wire-schema</code> library that models <code>.proto</code> schema definitions. This is a capable library that packs several neat features. You can load a <code>Schema</code> from <code>.proto</code> files located on the local file system, a ZIP or JAR file, or any <code>java.nio.FileSystem</code> like Jimfs. You can prune this schema with includes or excludes, allowing you to reuse <code>.proto</code> definitions with minimal code. And you can decode data directly from a schema: no code generation is necessary!</p> <p>We\u2019ve flattened extensions. Wire 2.0 combines the fields defined directly on messages with fields defined far away in extensions. In the generated code, extension fields look just like every other field! One limitation of this approach is that it\u2019s no longer possible to compile extensions separately from the messages they extend. For this reason we now recommend always generating all Wire code in a single step.</p> <p>We\u2019ve rearranged the runtime. Types related to the protocol buffers format are now prefixed <code>Proto</code> and types related to our implementation are prefixed <code>Wire</code>. To encode and decode messages you must first get an adapter either from the <code>ADAPTER</code> constant or from <code>ProtoAdapter.get()</code>. You no longer need a <code>Wire</code> instance!</p>"},{"location":"changelog/#runtime","title":"Runtime","text":"<ul> <li>New <code>ADAPTER</code> constant on most messages gives access to encode &amp; decode values. This replaces    the encoding and decoding methods on <code>Wire</code>.</li> <li>Guard against null lists. Code that passes <code>null</code> to builder methods expecting a <code>List</code> used to    accept that; now Wire throws a <code>NullPointerException</code>. Similarly list elements must also be    non-null.</li> <li>New <code>Message.newBuilder()</code> API. This replaces the previous copy constructor on <code>Builder</code>.</li> <li>New: <code>Message.withoutUnknownFields()</code> strips unknown fields.</li> <li>Fix: Always throw <code>ProtocolException</code> when there are decoding problems.</li> <li>Fix: Stricter checking for oneof fields. Previously it was possible to create instances with    multiple values set!</li> <li>Fix: Improve redacting of repeated fields.</li> <li>Fix: <code>ProtoReader</code> now silently unpacks packed values.</li> <li>Fix: <code>ProtoReader</code> doesn\u2019t return groups to callers.</li> </ul>"},{"location":"changelog/#schema-java-generator","title":"Schema &amp; Java Generator","text":"<ul> <li>The Java generator is now standalone. Use these APIs programmatically to build plugins without    delegating to the command line interface.</li> <li>New: Prune schemas using includes and excludes. The <code>IdentifierSet</code> can be used to configure    which types and members are retained and which are pruned.</li> <li>New: Encode and decode values directly from the schema.</li> <li>New: Improved error messages for validation.</li> <li>Fix: Strict imports.</li> <li>Fix: Detect and forbid conflicts on extension tags.</li> </ul>"},{"location":"changelog/#compiler","title":"Compiler","text":"<ul> <li>New: Always use Wire\u2019s bundled <code>descriptor.proto</code>. Previously to define custom options you    needed to import a potentially-inconsistent descriptor.</li> <li>New: Emit all types when no <code>.proto</code> files are explicitly specified.</li> <li>New: Generate code for encoding and decoding messages. The previous, reflection-based    encoder and decoder are accessible with <code>--compact</code>.</li> <li>New: <code>ServiceFactory</code> has been removed. To generate code for your services, load a schema with    <code>wire-schema</code> and then use a library like JavaPoet to generate your own code. The    <code>JavaGenerator</code> class can be used to look up Java names of message types.</li> <li>New: Compiler will load all <code>.proto</code> files if none are explicitly specified.</li> <li>New: Load <code>.proto</code> files from ZIP and JAR files.</li> <li>New: The <code>--android</code> flag causes Wire messages to implement <code>Parcelable</code>.</li> <li>New: Support multiple <code>--proto_path</code> arguments</li> <li>New: The <code>--named_files_only</code> flag limits which <code>.proto</code> files yield <code>.java</code> files. This was the    default in Wire 1.x.</li> <li>New: The <code>--no_options</code> flag has been deleted. Use <code>--excludes=google.protobuf.*</code> instead.</li> </ul>"},{"location":"changelog/#extensions","title":"Extensions","text":"<ul> <li>Extensions have been flattened.</li> <li>Fix: Better field resolution for options.</li> <li>Fix: Extension fields must not be <code>required</code>.</li> </ul>"},{"location":"changelog/#version-180","title":"Version 1.8.0","text":"<p>2015-06-27</p> <ul> <li>New: <code>oneof</code> support!</li> <li>Fix: Correct serialization of repeated unknown fields.</li> <li>Fix: Removed superfluous <code>private</code> modifier on enum constructor.</li> <li>Warning: The \u2018protoparser\u2019 library was updated to version 4.0. This changes the type passed to    any <code>ServiceWriter</code> implementations.</li> </ul>"},{"location":"changelog/#version-170","title":"Version 1.7.0","text":"<p>2015-03-05</p> <ul> <li>New: Messages implement <code>Serializable</code>. The serialized form follows protobuf encoding, so    renaming fields is safe as long as tags are consistent. (Renaming classes is unsafe, however).    Note that extension fields are deserialized as unknown fields.</li> </ul>"},{"location":"changelog/#version-161","title":"Version 1.6.1","text":"<p>2015-01-16</p> <ul> <li>New: <code>--quiet</code> and <code>--dry-run</code> command-line arguments.</li> <li>Fix: Handle an extension registry with zero or only one item.</li> <li>Okio dependency bumped to 1.2.0.</li> </ul>"},{"location":"changelog/#version-160","title":"Version 1.6.0","text":"<p>2014-10-23</p> <ul> <li>Fix: Correctly throw <code>IOException</code> when parsing bad input fails.</li> <li>Fix: Ensure emitted code references to <code>Arrays.asList</code> correctly compiles in some edge cases.</li> <li>\u2018UNDEFINED\u2019 enum value has been removed.</li> </ul>"},{"location":"changelog/#version-152","title":"Version 1.5.2","text":"<p>2014-09-15</p> <ul> <li>New: \u2018UNDEFINED\u2019 enum value represents values that the generated code is unable to handle.</li> <li>New: Service writer implementation can now be specified on the command-line.</li> </ul>"},{"location":"changelog/#version-151","title":"Version 1.5.1","text":"<p>2014-06-18</p> <ul> <li>New: Generate interface definition for a <code>Service</code> with a partial list of methods.</li> <li>Okio dependency bumped to 1.0.0.</li> </ul>"},{"location":"changelog/#version-150","title":"Version 1.5.0","text":"<p>2014-04-22</p> <ul> <li>New: Options on enums and enum values are now supported.</li> <li>New: Options ending with <code>.redacted</code> on fields will omit values from <code>toString</code>.</li> <li>New: <code>Redactor</code> creates copies of messages with redacted fields omitted.</li> <li>Various internal serialization improvements and memory reduction.</li> <li>Okio dependency bumped to 0.9.0.</li> </ul>"},{"location":"changelog/#version-140","title":"Version 1.4.0","text":"<p>2014-04-22</p> <ul> <li> <p>Replace Wire\u2019s ByteString class with the one from Okio (https://github.com/square/okio).    This is a breaking API change.</p> </li> <li> <p>Add a new static method <code>Wire.parseFrom(okio.Source input, Class&lt;M&gt; messageClass)</code>.</p> </li> <li> <p>Reimplement Wire\u2019s input handling to use Okio internally.</p> </li> <li> <p>Provide basic support for generating code from service declarations (see README.md).</p> </li> <li> <p>Improve deserialization performance.</p> </li> <li> <p>Fix a bug where no some extension dependencies were not detected.</p> </li> </ul>"},{"location":"changelog/#version-133","title":"Version 1.3.3","text":"<p>2014-03-28</p> <ul> <li>New: Support service declarations as roots. The request and response types of their methods will    be included.</li> </ul>"},{"location":"changelog/#version-132","title":"Version 1.3.2","text":"<p>2014-03-27</p> <ul> <li>Fix: Enum value duplicate check now correctly looks at names instead of values.</li> </ul>"},{"location":"changelog/#version-131","title":"Version 1.3.1","text":"<p>2014-03-25</p> <ul> <li>New: Automatically add Maven plugin\u2019s generated source as a compilation root.</li> <li>Fix: Correct Maven plugin\u2019s \u2018no arguments\u2019 flag to work properly.</li> <li>Fix: Support extend declarations nested inside message types.</li> </ul>"},{"location":"changelog/#version-130","title":"Version 1.3.0","text":"<p>2014-03-21</p> <ul> <li>New: Empty repeated fields are now initialized to an empty collection.</li> <li>New: Emit field options. Use <code>--no_options</code> flag to disable.</li> <li>New: <code>@Deprecated</code> is now added to fields and setters on the builder.</li> <li>New: Maven plugin for running the compiler as part of a build.</li> <li>Fix: Treat empty and null repeated fields the same in <code>equals()</code> and <code>hashCode()</code>.</li> </ul> <p>Note: This version is not backwards compatible with code generated from previous versions.</p>"},{"location":"changelog/#version-120","title":"Version 1.2.0","text":"<p>2013-11-01</p> <ul> <li>New: <code>--registry_class</code> compiler argument emits a class with a list of extensions suitable for    passing to the <code>Wire</code> constructor.</li> <li>Fix: Ensure all trailing whitespace is trimmed on documentation.</li> </ul>"},{"location":"changelog/#version-111","title":"Version 1.1.1","text":"<p>2013-10-23</p> <ul> <li>Fix: Correct parsing and emission of multi-line documentation.</li> </ul>"},{"location":"changelog/#version-110","title":"Version 1.1.0","text":"<p>2013-10-22</p> <ul> <li>New: Support for message options.</li> <li>New: Check for duplicate field tag numbers.</li> <li>New: Emit Javadoc on messages, enum values, and builder methods.</li> <li>Fix: Emit imports for extension fields and classes outside of package.</li> <li>Fix: Correctly generate sources for protos with the same basename.</li> <li>Fix: Do not generate default constants for message types.</li> <li>Fix: Avoid shadowing fields named \u201cresult\u201d, \u201cother\u201d, or \u201co\u201d.</li> </ul>"},{"location":"changelog/#version-101","title":"Version 1.0.1","text":"<p>2013-08-27</p> <ul> <li>New: Support reading directly from <code>InputStream</code>.</li> <li>New: Add \u2018<code>other == this</code>\u2019 shortcut in generated <code>equals()</code> methods.</li> </ul>"},{"location":"changelog/#version-100","title":"Version 1.0.0","text":"<p>2013-08-23</p> <p>Initial version.</p>"},{"location":"code_of_conduct/","title":"Open Source Code of Conduct","text":"<p>At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone.</p> <p>This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored.</p> <p>Square\u2019s open source community strives to:</p> <ul> <li> <p>Be open: We invite anyone to participate in any aspect of our projects. Our community is    open, and any responsibility can be carried by a contributor who demonstrates the required    capacity and competence.</p> </li> <li> <p>Be considerate: People use our work, and we depend on the work of others. Consider users and    colleagues before taking action. For example, changes to code, infrastructure, policy, and    documentation may negatively impact others.</p> </li> <li> <p>Be respectful: We expect people to work together to resolve conflict, assume good intentions,    and act with empathy. Do not turn disagreements into personal attacks.</p> </li> <li> <p>Be collaborative: Collaboration reduces redundancy and improves the quality of our work. We    strive for transparency within our open source community, and we work closely with upstream    developers and others in the free software community to coordinate our efforts.</p> </li> <li> <p>Be pragmatic: Questions are encouraged and should be asked early in the process to avoid    problems later. Be thoughtful and considerate when seeking out the appropriate forum for your    questions. Those who are asked should be responsive and helpful.</p> </li> <li> <p>Step down considerately: Members of every project come and go. When somebody leaves or    disengages from the project, they should make it known and take the proper steps to ensure that    others can pick up where they left off.</p> </li> </ul> <p>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.</p>"},{"location":"code_of_conduct/#diversity-statement","title":"Diversity Statement","text":"<p>We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal.</p> <p>Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong.</p> <p>Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.</p>"},{"location":"code_of_conduct/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. For more details, please see our Reporting Guidelines below.</p>"},{"location":"code_of_conduct/#thanks","title":"Thanks","text":"<p>Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter, Ubuntu, GDC, and Django communities. We are thankful for their work.</p>"},{"location":"code_of_conduct/#reporting-guide","title":"Reporting Guide","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. All reports will be handled with discretion.</p> <p>In your report please include:</p> <ul> <li>Your contact information.</li> <li>Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional    witnesses, please include them as well.</li> <li>Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly    available record (e.g. a mailing list archive or a public IRC logger), please include a link.</li> <li>Any additional information that may be helpful.</li> </ul> <p>After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond.</p> <p>Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome.</p> <p>If you\u2019ve found a security problem, please follow our bug bounty program.</p> <p>If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it.</p> <p>Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA).</p>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":"<p>Get working code on a personal branch with tests passing before you submit a PR:</p> <pre><code>./gradlew clean check\n</code></pre> <p>Please make every effort to follow existing conventions and style in order to keep the code as readable as possible.</p> <p>Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge.</p>"},{"location":"contributing/#committers-guides","title":"Committer\u2019s Guides","text":"<ul> <li>Releasing</li> </ul>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#supported-versions","title":"Supported Versions","text":"Version Supported 4.x \u2705 3.x \u2705 2.x 1.x"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository.</p> <p>If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource</p>"},{"location":"wire_compiler/","title":"Wire Compiler &amp; Gradle Plugin","text":"<p>Wire has two key components: a compiler that generates source code at build time, and a runtime library that supports the generated code when your program executes. The compiler is very configurable; this guide explains its features and their use.</p>"},{"location":"wire_compiler/#getting-started","title":"Getting Started","text":"<p>The best way to configure and execute the Wire compiler is via our Gradle plugin. It requires Gradle 5.5 or newer.</p> <p>A typical project has <code>.proto</code> files in the standard <code>src/main/proto</code> directory.</p> <pre><code>src/\n  main/\n    proto/\n      com/\n        example/\n          pizza/\n            pizza_delivery.proto\n            pizza.proto\n          sales/\n            price.proto\n            store.proto\n          geo/\n            address.proto\n            country.proto\n    kotlin/\n      com/\n        example/\n          pizza/\n            PizzaApp.kt\n  test/\n    kotlin/\n      com/\n        example/\n          pizza/\n            PizzaAppTest.kt\nbuild.gradle\n</code></pre> <p>Because this project uses the default configuration, plugin setup is easy. Just a simple block in <code>build.gradle</code>,</p> <p>Using plugin application: <pre><code>buildscript {\n  repositories {\n    mavenCentral()\n  }\n  dependencies {\n    classpath 'com.squareup.wire:wire-gradle-plugin:&lt;version&gt;'\n  }\n}\n\napply plugin: 'com.squareup.wire'\n\nwire {\n  kotlin {}\n}\n</code></pre></p> <p>Using the plugins DSL: <pre><code>plugins {\n  id 'application'\n  id 'org.jetbrains.kotlin.jvm'\n  id 'com.squareup.wire'\n}\n\nwire {\n  kotlin {}\n}\n</code></pre></p> <p>The plugin will read the <code>.proto</code> schema definitions, validate them, link them, and generate Kotlin code. It uses KotlinPoet internally to generate compact and legible source files.</p> <p></p> <p>If <code>sourcePath</code> isn\u2019t set, Wire will look for <code>.proto</code> files in <code>src/main/proto</code> by default.</p> <p>Wire will generate files in <code>build/generated/source/wire</code>. It\u2019ll also register this directory as a source directory for the project so the generated sources are compiled by the Kotlin compiler.</p> <p>Replace <code>kotlin</code> with <code>java</code> to generate the Java sources instead.</p>"},{"location":"wire_compiler/#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>Wire can pull source <code>.proto</code> schema definitions from a local directory, a local <code>.jar</code> file, or an external artifact specified with Maven coordinates.</p> <pre><code>wire {\n  sourcePath {\n    srcDir 'src/main/protos'\n  }\n\n  sourcePath {\n    srcJar 'lib/pizza-protos.jar'\n  }\n\n  sourcePath {\n    srcJar 'com.example.pizza:pizza-protos:1.0.0'\n  }\n\n  ...\n}\n</code></pre> <p>If your resource or directory contains more <code>.proto</code> files than you need to compile you can constrain the inputs to specific files:</p> <pre><code>wire {\n  sourcePath {\n    srcDir 'src/main/protos'\n    include 'com/example/pizza/pizza_delivery.proto'\n    include 'com/example/pizza/pizza.proto'\n  }\n}\n</code></pre> <p>Wildcards (with two stars) are also accepted:</p> <pre><code>wire {\n  sourcePath {\n    srcDir 'src/main/protos'\n    include 'com/example/pizza/**'\n  }\n}\n</code></pre> <p>You can also do the opposite and exclude some files: <pre><code>wire {\n  sourcePath {\n    srcDir 'src/main/protos'\n    exclude 'com/example/juice/**'\n    exclude 'com/example/pizza/toppings.proto'\n  }\n}\n</code></pre></p> <p>Wire can emit multiple languages in the same build. Use <code>includes</code> to specify which types are emitted for a target language; subsequent languages will emit what\u2019s left over.</p> <pre><code>wire {\n  ...\n\n  kotlin {\n    // Kotlin emits the matched types only.\n    includes = ['com.example.pizza.*']\n  }\n  java {\n    // Java gets everything else!\n  }\n}\n</code></pre> <p>Note that sources are specified as file system paths (slash delimiter) and targets are specified as Proto type names (dot delimiter).</p> <p></p> <p>You may also specify targets with excludes. If you have both includes and excludes, excludes take precedence.</p> <pre><code>wire {\n  ...\n\n  kotlin {\n    // Kotlin emits everything but sales and geo packages.\n    excludes = ['com.example.sales.*', 'com.example.geo.*']\n  }\n  java {\n    // Java gets those because they're left over.\n  }\n}\n</code></pre> <p>Wire will print a warning if any name in includes or excludes is unused.</p> <p>When configuring Wire you must use the package name from the <code>.proto</code> file\u2019s <code>package</code> declaration. The <code>option java_package</code> name is not used for Wire configuration.</p>"},{"location":"wire_compiler/#proto-path-for-libraries","title":"Proto Path for Libraries","text":"<p>Large projects may span multiple modules. To support this Wire has a \u2018proto path\u2019. The <code>.proto</code> schema files on this path are used for linking and validation, but they do not yield files in the generated output.</p> <p>The proto path supports the same inputs as the source path: directories, <code>.jar</code> files, and Maven coordinates. Similarly, the proto path may be filtered with <code>include</code>.</p> <pre><code>wire {\n  protoPath {\n    srcDir 'src/main/address-protos'\n  }\n\n  protoPath {\n    srcJar 'lib/price.jar'\n  }\n\n  protoPath {\n    srcJar 'com.example:countries:1.0.0'\n    include 'com/example/geo/country.proto'\n  }\n\n  protoPath {\n    srcDir 'src/main/extra-protos'\n    exclude 'com/example/**'\n  }\n\n  ...\n}\n</code></pre> <p>The source path and proto path are linked together but only types on the source path are generated.</p> <p></p>"},{"location":"wire_compiler/#dependencies-between-gradle-modules","title":"Dependencies between Gradle Modules","text":"<p>Wire provides support to define dependencies between modules within the same project.</p> <p>A module can include its <code>.proto</code> files into the output resources. Use this when your <code>.jar</code> file can be used as a library for other proto or Wire projects. Note that only the <code>.proto</code> files used in the library will be included.</p> <pre><code>wire {\n  protoLibrary = true\n}\n</code></pre> <p>Wire also creates two configurations, <code>protoPath</code> and <code>protoSource</code> you can use to define a dependency on another proto or Wire project.</p> <pre><code>dependencies {\n  // The task `:common-protos:jar` will be added into the dependency\n  // graph of this module for the Wire generating tasks.\n  protoPath(project(':common-protos'))\n  implementation(project(':common-protos'))\n}\n\nwire {\n  kotlin {\n  }\n}\n</code></pre> <p>Note that <code>protoPath</code> and <code>protoSource</code> dependencies are not transitive by default. If needed, you can change it manually.</p> <pre><code>configurations.protoPath {\n  transitive = true\n}\n</code></pre>"},{"location":"wire_compiler/#pruning","title":"Pruning","text":"<p>For mobile projects it\u2019s easy to generate a lot of unnecessary code. For example, a <code>.proto</code> schema might support types for obsolete features.</p> <p>General-purpose code-shrinking tools like R8 and ProGuard have difficulty shrinking Wire-generated sources because the <code>encode()</code> and <code>decode()</code> functions still use them. Instead, Wire offers its own code shrinker to eliminate unwanted declarations early.</p> <p>Use <code>prune</code> to precisely eliminate an unwanted type or member. These will be eliminated along with all references to them.</p> <pre><code>wire {\n  ...\n\n  prune 'com.example.store.Store'\n  prune 'com.example.geo.Country'\n\n  ...\n}\n</code></pre> <p></p> <p>Alternately you may prefer to specify what to keep, pruning everything not reachable from that set.</p> <pre><code>wire {\n  ...\n\n  root 'com.example.pizza.PizzaDelivery'\n\n  ...\n}\n</code></pre> <p>By default this feature is strict given unknown <code>root</code> and <code>prune</code> arguments. You may prefer for this to be lenient instead:</p> <pre><code>wire {\n  rejectUnusedRootsOrPrunes = false\n  ...\n}\n</code></pre>"},{"location":"wire_compiler/#version-matching","title":"Version Matching","text":"<p>Another way to prune obsolete fields is to assign them a version, then to generate your code against a version range or a unique version. The fields out of the version range will get pruned.</p> <p>Members may be declared with <code>wire.since</code> and <code>wire.until</code> options; enum constant can use <code>wire.constant_since</code> and <code>wire.constant_until</code>. For example, these options declare a field <code>age</code> that was replaced with <code>birth_date</code> in version \u201c5.0\u201d:</p> <pre><code>import \"wire/extensions.proto\";\n\nmessage Singer {\n  optional string name = 1;\n  optional int32 age = 2 [(wire.until) = \"5.0\"];\n  optional Date birth_date = 3 [(wire.since) = \"5.0\"];\n}\n</code></pre> <p>Client code should typically target a single version. In this example, clients will have the <code>name</code> and <code>birth_date</code> fields only.</p> <pre><code>wire {\n  onlyVersion \"5.0\"\n}\n</code></pre> <p>Service code that supports many clients should support the union of versions of all supported clients. Such code will have <code>name</code>, as well as both the <code>age</code> and <code>birth_date</code> fields.</p> <pre><code>wire {\n  sinceVersion \"3.0\"\n  untilVersion \"6.0\"\n}\n</code></pre>"},{"location":"wire_compiler/#proto-libraries","title":"Proto Libraries","text":"<p>By default, <code>.proto</code> input files are not included in the generated <code>.jar</code> artifact. Use the <code>protoLibrary</code> option to include them:</p> <pre><code>wire {\n  protoLibrary = true\n}\n</code></pre> <p>This is most useful when building <code>.jar</code> files for other <code>wire</code> tasks to use as dependencies. Note that only the true sources are included \u2013 proto messages that are pruned or not used are not included in the output artifact.</p>"},{"location":"wire_compiler/#dry-run","title":"Dry run","text":"<p>With the dry run option, the compiler will just emit the names of the source files that would be otherwise generated to stdout.</p> <pre><code>wire {\n  dryRun = true\n}\n</code></pre>"},{"location":"wire_compiler/#customizing-output","title":"Customizing Output","text":""},{"location":"wire_compiler/#java","title":"Java","text":"<p>Here\u2019s an exhaustive Java configuration. Booleans are shown with their default behavior.</p> <pre><code>wire {\n  java {\n    // Proto types to include generated sources for. Types listed here will be\n    // generated for this target and not for subsequent targets in the task.\n    //\n    // This list should contain package names (suffixed with `.*`) and type\n    // names only. It should not contain member names.\n    includes = ['com.example.pizza.*']\n\n    // Proto types to excluded generated sources for. Types listed here will\n    // not be generated for this target.\n    //\n    // This list should contain package names (suffixed with `.*`) and type\n    // names only. It should not contain member names.\n    excludes = ['com.example.sales.*']\n\n    // True if types emitted for this target should not also be emitted for\n    // other targets. Use this to cause multiple outputs to be emitted for the\n    // same input type.\n    exclusive = true\n\n    // Directory to emit to.\n    out \"${buildDir}/custom\"\n\n    // True for emitted types to implement android.os.Parcelable.\n    android = false\n\n    // True to enable the androidx.annotation. Nullable annotation\n    // where applicable.\n    androidAnnotations = false\n\n    // True to emit code that uses reflection for reading, writing, and toString\n    // methods which are normally implemented with generated code.\n    compact = false\n\n    // True to turn visibility of all generated types' constructors\n    // to non-public.\n    buildersOnly = false\n\n    // True to emit types for options declared on messages, fields, etc.\n    emitDeclaredOptions = true\n\n    // True to emit annotations for options applied on messages, fields, etc.\n    emitAppliedOptions = true\n  }\n}\n</code></pre>"},{"location":"wire_compiler/#kotlin","title":"Kotlin","text":"<p>Here\u2019s an exhaustive Kotlin configuration. Booleans and enums are shown with their default behavior.</p> <pre><code>wire {\n  kotlin {\n    // Proto types to include generated sources for. Types listed here will be\n    // generated for this target and not for subsequent targets in the task.\n    //\n    // This list should contain package names (suffixed with `.*`) and type\n    // names only. It should not contain member names.\n    includes = ['com.example.pizza.*']\n\n    // Proto types to excluded generated sources for. Types listed here will not\n    // be generated for this target.\n    //\n    // This list should contain package names (suffixed with `.*`) and type\n    // names only. It should not contain member names.\n    excludes = ['com.example.sales.*']\n\n    // True if types emitted for this target should not also be emitted for\n    // other targets. Use this to cause multiple outputs to be emitted for the\n    // same input type.\n    exclusive = true\n\n    // Directory to emit to.\n    out \"${buildDir}/custom\"\n\n    // True for emitted types to implement android.os.Parcelable.\n    android = false\n\n    // True for emitted types to implement APIs for easier migration from the\n    // Java target.\n    javaInterop = false\n\n    // True to turn visibility of all generated types' constructors\n    // to non-public.\n    buildersOnly = false\n\n    // True to emit types for options declared on messages, fields, etc.\n    emitDeclaredOptions = true\n\n    // True to emit annotations for options applied on messages, fields, etc.\n    emitAppliedOptions = true\n\n    // `suspending` to generate coroutines APIs that require a Kotlin\n    // coroutines context.\n    // `blocking` to generate blocking APIs callable by Java and Kotlin.\n    rpcCallStyle = 'blocking'\n\n    // `client` to generate interfaces best suited to sending outbound calls.\n    // `server` to generate interfaces best suited to receiving inbound calls.\n    // `none` to not generate services.\n    rpcRole = 'server'\n\n    // If set, the value will be appended to generated service type names. If\n    // null, their rpcRole will be used as a suffix instead.\n    nameSuffix = \"Suffix\"\n\n    // True for emitted services to implement one interface per RPC.\n    singleMethodServices = false\n\n    // Set how many oneof choices are necessary for generated message classes to use the\n    // `OneOf&lt;Key&lt;T&gt;, T&gt;` form rather than the default, where options are flattened into the\n    // enclosing type.\n    boxOneOfsMinSize = 5000\n\n    // True to escape Kotlin keywords like `value` and `data` with backticks. Otherwise an\n    // underscore underscore is added as a suffix, like `value_` and `data_`.\n    escapeKotlinKeywords = false\n\n    // Defines how an protobuf enum type is to be generated. See `com.squareup.wire.kotlin.EnumMode`\n    enumMode = \"enum_class\"\n\n    // True to emit a adapters that include a decode() function that accepts a `ProtoReader32`.\n    // Use this optimization when targeting Kotlin/JS, where `Long` cursors are inefficient.\n    emitProtoReader32 = false\n  }\n}\n</code></pre>"},{"location":"wire_compiler/#proto","title":"Proto","text":"<p>Here\u2019s an exhaustive Proto configuration. You can use this target to generate a pruned proto schema, or to pretty-print one. Note that even with multiple outputs set, the proto target will always emit all types, all services, and all extensions of the schema.</p> <pre><code>wire {\n  proto {\n    // Directory to emit to.\n    out \"${buildDir}/custom\"\n  }\n}\n</code></pre>"},{"location":"wire_compiler/#custom-handlers","title":"Custom Handlers","text":"<p>With a custom schema handler, you can handle a proto schema in any way you want, including code generation or other side effects such as validation, logging, etc.</p> <p>You\u2019ll need to first extend the SchemaHandler class, and then the SchemaHandler.Factory interface which is to return an instance of the former. See our recipes for different use cases\u2019 implementations.</p> <p>Build that into an <code>jar</code> artifact and add that as a buildscript dependency to your Gradle project.</p> <pre><code>buildscript {\n  dependencies {\n    classpath \"com.example.my-custom-handler:my-custom-handler:1.0.0\"\n  }\n}\n</code></pre> <p>Next configure the Wire plugin to call your custom handler. Here\u2019s an exhaustive custom configuration. Booleans and enums are shown with their default behavior.</p> <pre><code>wire {\n  custom {\n    // The name of a Java class to generate code with. This class must:\n    //  * be in the buildscript dependencies for this Gradle project\n    //  * be a public class\n    //  * have a public no-arguments constructor\n    //  * implement the com.squareup.wire.schema.SchemaHandler.Factory interface\n    schemaHandlerFactoryClass = \"com.example.MyCustomHandlerFactory\"\n\n    // These options work the same as the java and kotlin targets above.\n    includes = ['com.example.pizza.*']\n    excludes = ['com.example.sales.*']\n    exclusive = true\n    out \"${buildDir}/custom\"\n\n    // Custom payload which can be passed to the `SchemaHandler.Factory`.\n    options = [a: \"one\", b: \"two\", c: \"three\"]\n  }\n}\n</code></pre>"},{"location":"wire_compiler/#swift-support","title":"Swift Support","text":"<p>The easiest way to get started is to use CocoaPods.</p> <pre><code># Add the Wire compiler so that it is downloaded and available.\n# CocoaPods will download the source and build the compiler directly,\n# so you'll need Java installed.\npod 'WireCompiler'\n\n# Add the Wire runtime to do the serializing/deserializing\npod 'Wire'\n</code></pre> <p>Then run pod install to get the dependencies and build the Wire compiler.</p> <p>Swift Package Manager is also supported for linking the Wire runtime.</p>"},{"location":"wire_compiler/#build-your-protos","title":"Build Your Protos","text":"<p>The Wire compiler uses SwiftPoet to generate Swift code. The resulting objects automatically conform to <code>Equatable</code>, <code>Codable</code> and <code>Sendable</code>.</p> <p>Assuming you\u2019ve used CocoaPods to download the Wire compiler, to compile your protos into Swift files:</p> <pre><code>java -jar ./Pods/WireCompiler/compiler.jar \\\n  \"--proto_path=&lt;directory containing .proto files&gt;\" \\\n  \"--swift_out=&lt;directory where the generated .swift files go&gt;\" \\\n  \"--experimental-module-manifest=&lt;path to manifest yaml file&gt;\"\n</code></pre>"},{"location":"wire_compiler/#swift-manifest","title":"Swift Manifest","text":"<p>Swift introduced a new challenge that didn\u2019t exist with Kotlin and Java: modules. Kotlin and Java both use fully-qualified package names, but Swift modules are defined by their compilation unit, and thus namespaces aren\u2019t declared at the type or file level. This meant that we needed to build a new packaging system for Swift that could deal with Swift module namespacing and imports.</p> <p>We decided that the easiest way for a caller to define modules was to make those definitions handled directly by Wire. A single manifest file defines the modules, their names, their dependencies, and the content roots and prunes mentioned above.</p> <p>In this example manifest the DarkSide and LightSide modules would depend on and import the CommonProtos module:</p> <pre><code>CommonProtos:\n  roots:\n    - jedi.Lightsaber\n    - jedi.MindTrick\n    - jedi.TheForce\n    - jedi.Anakin\n\nDarkSideProtos:\n  dependencies:\n    - CommonProtos\n  roots:\n    - darkside.*\n    - jedi.Lightning\n  prunes:\n    - jedi.Mercy\n\nLightSideProtos:\n  dependencies:\n    - CommonProtos\n  roots:\n    - lightside.*\n    # Import the rest of the Jedi powers not already in CommonProtos\n    - jedi.*\n  prunes:\n    # Remove unused lightsaber colors\n    - jedi.LightsaberColor#red\n    # Remove deprecated field. Use green_lightsaber instead.\n    - lightside.Luke#blue_lightsaber\n    # Remove dark-side-only types\n    - jedi.Lightning\n</code></pre>"},{"location":"wire_grpc/","title":"Wire gRPC","text":"<p>The Wire compiler will generate interfaces for your service RPCs defined in your protobuf schema; under the condition that the target is set to Kotlin.</p>"},{"location":"wire_grpc/#getting-started","title":"Getting Started","text":"<p>You can configure how your services are generated via the Gradle plugin:</p> <pre><code>wire {\n  // Kotlin target will generate code for services.\n  kotlin {\n    // `client` to generate interfaces best suited to sending outbound calls.\n    // `server` to generate interfaces best suited to receiving inbound calls.\n    rpcRole = 'server'\n    // Server only\n    // `suspending` to generate coroutines APIs that require a Kotlin coroutines context.\n    // `blocking` to generate blocking APIs callable by Java and Kotlin.\n    rpcCallStyle = 'suspending'\n    // Server only\n    // True for emitted services to generate one interface per RPC.\n    singleMethodServices = false\n  }\n}\n</code></pre> <p>The generated code varies depending on your RPC role, namely client or server. We\u2019ll use the following schema to demonstrate how they differ:</p> <pre><code>syntax = \"proto2\";\n\npackage routeguide;\n\nservice RouteGuide {\n  // A simple RPC.\n  rpc GetFeature(Point) returns (Feature) {}\n\n  // A server-to-client streaming RPC.\n  rpc ListFeatures(Rectangle) returns (stream Feature) {}\n\n  // A client-to-server streaming RPC.\n  rpc RecordRoute(stream Point) returns (RouteSummary) {}\n\n  // A Bidirectional streaming RPC.\n  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n}\n</code></pre>"},{"location":"wire_grpc/#grpc-for-clients","title":"gRPC for Clients","text":"<p>For the schema <code>RouteGuide</code>, when <code>rpcRole</code> is <code>client</code>, the Wire compiler will generate the following interface: <pre><code>interface RouteGuideClient : Service {\n  fun GetFeature(): GrpcCall&lt;Point, Feature&gt;\n\n  fun ListFeatures(): GrpcStreamingCall&lt;Rectangle, Feature&gt;\n\n  fun RecordRoute(): GrpcStreamingCall&lt;Point, RouteSummary&gt;\n\n  fun RouteChat(): GrpcStreamingCall&lt;RouteNote, RouteNote&gt;\n}\n</code></pre></p> <p>For streaming APIs, we return a GrpcStreamingCall, and a GrpcCall otherwise. With these objects, the caller can communicate with the server. Both blocking and suspending APIs are provided.</p>"},{"location":"wire_grpc/#wire-runtime","title":"Wire runtime","text":"<p>To help you instantiate your service, we provide a small runtime, namely GrpcClient:</p> <pre><code>val grpcClient = GrpcClient.Builder()\n  .client(OkHttpClient.Builder().protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE)).build())\n  .baseUrl(serverUrl)\n  .build()\nval routeGuideClient = grpcClient.create(RouteGuideClient::class)\n</code></pre>"},{"location":"wire_grpc/#grpc-for-servers","title":"gRPC for Servers","text":""},{"location":"wire_grpc/#blocking-apis","title":"Blocking APIs","text":"<p>Following this configuration: <pre><code>wire {\n  kotlin {\n    rpcRole = 'server'\n    rpcCallStyle = 'blocking'\n  }\n}\n</code></pre> the Wire compiler will generate the following interface for the server to implement: <pre><code>interface RouteGuideBlockingServer : Service {\n  fun GetFeature(request: Point): Feature\n\n  fun ListFeatures(request: Rectangle, response: MessageSink&lt;Feature&gt;)\n\n  fun RecordRoute(request: MessageSource&lt;Point&gt;): RouteSummary\n\n  fun RouteChat(request: MessageSource&lt;RouteNote&gt;, response: MessageSink&lt;RouteNote&gt;)\n}\n</code></pre> For streaming connections, the server can use Wire\u2019s blocking APIs: MessageSource and MessageSink.</p>"},{"location":"wire_grpc/#suspending-apis","title":"Suspending APIs","text":"<p>Following this configuration: <pre><code>wire {\n  kotlin {\n    rpcRole = 'server'\n    rpcCallStyle = 'suspending'\n  }\n}\n</code></pre> the Wire compiler will generate the following interface for the server to implement: <pre><code>interface RouteGuideServer : Service {\n  suspend fun GetFeature(request: Point): Feature\n\n  fun ListFeatures(request: Rectangle, response: SendChannel&lt;Feature&gt;)\n\n  fun RecordRoute(request: ReceiveChannel&lt;Point&gt;): RouteSummary\n\n  fun RouteChat(request: ReceiveChannel&lt;RouteNote&gt;, response: SendChannel&lt;RouteNote&gt;)\n}\n</code></pre> The server can use Kotlin coroutines\u2019 suspend and Channels mechanisms to execute suspending network calls.</p>"},{"location":"wire_grpc/#implementing-client-interfaces","title":"Implementing Client Interfaces","text":"<p>Wire has helper functions to make it easier to implement its client interfaces. This can be particularly useful for testing. It supports both streaming and non-streaming APIs in Kotlin:</p> <pre><code>class FakeRouteGuideClient : RouteGuideClient {\n  override fun GetFeature(): GrpcCall&lt;Point, Feature&gt; {\n    return GrpcCall { request: Point -&gt;\n      return@GrpcCall Feature(name = \"test\", location = request)\n    }\n  }\n\n  override fun RouteChat(): GrpcStreamingCall&lt;RouteNote, RouteNote&gt; {\n    return GrpcStreamingCall { requests: ReceiveChannel&lt;RouteNote&gt;, responses: SendChannel&lt;RouteNote&gt; -&gt;\n      try {\n        requests.consumeEach { routeNote: RouteNote -&gt;\n          responses.send(RouteNote(message = \"ACK: ${routeNote.message}\"))\n        }\n      } finally {\n        responses.close()\n      }\n    }\n  }\n\n  ...\n}\n</code></pre> <p>The <code>GrpcCall</code> and <code>GrpcStreamingCall</code> functions are well suited to expression functions:</p> <pre><code>class FakeRouteGuideClient : RouteGuideClient {\n  override fun GetFeature() =\n      GrpcCall&lt;Point, Feature&gt; { request -&gt;\n        return@GrpcCall Feature(name = \"test\", location = request)\n      }\n\n  override fun RouteChat() =\n      GrpcStreamingCall&lt;RouteNote, RouteNote&gt; { requests, responses -&gt;\n        try {\n          requests.consumeEach { routeNote -&gt;\n            responses.send(RouteNote(message = \"ACK: ${routeNote.message}\"))\n          }\n        } finally {\n          responses.close()\n        }\n      }\n\n  ...\n}\n</code></pre> <p>The client interface may also be implemented in Java. Wire only offers a non-streaming helper function. The <code>GrpcStreamingCall</code> above uses coroutines which is Kotlin-only.</p> <pre><code>public class FakeRouteGuideClient implements RouteGuideClient {\n  @Override public GrpcCall&lt;Point, Feature&gt; GetFeature() {\n    return GrpcCalls.grpcCall(new Function1&lt;Point, Feature&gt;() {\n      @Override public Feature invoke(Point request) {\n        return new Feature.Builder()\n            .name(\"test\")\n            .location(request)\n            .build();\n      }\n    });\n  }\n\n  ...\n}\n</code></pre> <p>These similarly interact nicely with Java lambdas.</p>"},{"location":"wire_grpc/#sample","title":"Sample","text":"<p>Check out our sample project demonstrating bidirectional communication between an Android application and a server.</p>"},{"location":"wire_grpc/#get-it","title":"Get it","text":"<p>Use Wire runtime Gradle coordinates: <pre><code>implementation(\"com.squareup.wire:wire-runtime:LATEST_VERSION\")\n</code></pre></p> <p>In addition, to use Wire gRPC for clients, use these new Gradle coordinates:</p> <pre><code>implementation(\"com.squareup.wire:wire-grpc-client:LATEST_VERSION\")\n</code></pre>"},{"location":"wire_grpc/#wire-grpc-server","title":"wire-grpc-server","text":"<p>The modules <code>wire-grpc-server</code> and <code>wire-grpc-server-generator</code> have been extracted out of Wire 5. They now live as a standalone repository square/wire-grpc-server/.</p> <p>Here are the steps for a smooth migration:</p>"},{"location":"wire_grpc/#maven-coordinates","title":"Maven Coordinates","text":"<p>Update the coordinates for <code>com.squareup.wire:wire-grpc-server</code>. <pre><code>-com.squareup.wire:wire-grpc-server:&lt;wire-version&gt;\n+com.squareup.wiregrpcserver:server:&lt;new-repo-version&gt;\n</code></pre></p> <p>Add a new dependency on the classpath Wire will run on.</p> <pre><code>classpath(\"com.squareup.wiregrpcserver:server-generator:&lt;new-repo-version&gt;\")\n</code></pre>"},{"location":"wire_grpc/#configuration","title":"Configuration","text":"<p>Before <pre><code>wire {\n  kotlin {\n    rpcRole = \"server\"\n    grpcServerCompatible = true\n    singleMethodServices = false\n    rpcCallStyle = \"suspending\"\n  }\n}\n</code></pre></p> <p><code>grpcServerCompatible</code> does not exist anymore. You are to pass the new <code>GrpcServerSchemaHandler</code> to Wire in a custom block.</p> <p>After <pre><code>wire {\n  custom {\n    // Be sure that `server-generator` is on the classpath for Gradle to resolve\n    // `GrpcServerSchemaHandler`.\n    schemaHandlerFactory = com.squareup.wire.kotlin.grpcserver.GrpcServerSchemaHandler.Factory()\n    options = mapOf(\n      // Defaults to `true` if absent. Any other value than `true` is considered false.\n      \"singleMethodServices\" to \"false\",\n      // Defaults to `suspending` if absent. Any other value than `suspending` is considered\n      // non-suspending.\n      \"rpcCallStyle\" to \"suspending\",\n    )\n    // We set the custom block exclusivity to false so that the next `kotlin {}` block can also\n    // generate the protobuf Messages.\n    exclusive = false\n  }\n\n  kotlin {\n    rpcRole = \"server\"\n    singleMethodServices = false\n    rpcCallStyle = \"suspending\"\n  }\n}\n</code></pre></p> <p>For any problem with the migration, please ask on wire-grpc-server.</p>"},{"location":"wire_json/","title":"Wire JSON","text":"<p>Wire offers JSON serialization over Moshi or Gson. We provide an adapter factory for both to configure them to deal with protobuf specifics.</p>"},{"location":"wire_json/#moshi","title":"Moshi","text":"<p>Moshi support is part of the <code>wire-moshi-adapter</code> module. It has to be added to the project dependencies in order to plug the <code>WireJsonAdapterFactory</code> into Moshi.</p> <p>The Maven coordinates are: <code>com.squareup.wire:wire-moshi-adapter:&lt;version&gt;</code></p> <pre><code>val moshi = Moshi.Builder()\n      .add(WireJsonAdapterFactory())\n      .build()\n\nval adapter = moshi.adapter(Pizza::class.java)\nval pizza: Pizza = ...\nval json = adapter.toJson(pizza)\nval parsedPizza = adapter.fromJson(json)\n</code></pre>"},{"location":"wire_json/#gson","title":"Gson","text":"<p>Moshi support is part of the <code>wire-gson-support</code> module. It has to be added to the project dependencies in order to plug the <code>WireTypeAdapterFactory</code> into Gson.</p> <p>The Maven coordinates are: <code>com.squareup.wire:wire-gson-support:&lt;version&gt;</code></p> <pre><code>val gson = GsonBuilder()\n      .registerTypeAdapterFactory(WireTypeAdapterFactory())\n      .create()\n\nval adapter = gson.adapter(Pizza::class.java)\nval pizza: Pizza = ...\nval json = adapter.toJson(pizza)\nval parsedPizza = adapter.fromJson(json)\n</code></pre>"},{"location":"wire_json/#protoc","title":"Protoc","text":"<p>Wire is interoperable with protoc for all proto3 messages. The JSON representation of proto2 is unspecified. JSON representations of proto2 messages from Wire and protoc are not interoperable. Note that by default Protoc throws an error for unknown fields. Wire will ignore them.</p>"},{"location":"wire_vs_protoc/","title":"Wire versus Protoc","text":""},{"location":"wire_vs_protoc/#non-primitive-types","title":"Non-Primitive Types","text":"<p>Protoc generates literal equivalents for all the Proto3 new types like <code>empty</code>, <code>struct</code>, etc. Wire tries to reuse existing types in the corresponding language when possible. The only new type Wire brings is <code>AnyMessage</code> for the <code>google.protobuf.Any</code> proto type.</p>"},{"location":"wire_vs_protoc/#any","title":"Any","text":"<p>The <code>Any</code> type wraps an arbitrary protobuf message by holding a field to identify its type and another field for storing the serialized representation of the wrapped message. Wire comes with its own <code>AnyMessage</code> type to represent <code>google.protobuf.Any</code>.</p> <pre><code>class AnyMessage(\n  val typeUrl: String,\n  val value: okio.ByteString\n)\n</code></pre> <p>It comes with a few methods to wrap or unwrap the embedded message.</p> <pre><code>// Wire\nval anyMessage: AnyMessage = AnyMessage.pack(person)\nval person: Person = anyMessage.unpack(Person.ADAPTER)\n\n// Protoc\nval any: Any = Any.pack(foo)\nval person: Person = any.unpack(Person.class)\n</code></pre>"},{"location":"wire_vs_protoc/#duration-timestamp","title":"Duration &amp; Timestamp","text":"<p>Both <code>google.protobuf.Duration</code> and <code>google.protobuf.Timestamp</code> types will be generated by using their JVM equivalent: <code>java.time.Duration</code> and <code>java.time.Instant</code>. For non-JVM platforms, we provide two new Wire types with the same APIs:</p> <pre><code>class com.squareup.wire.Duration {\n  fun getSeconds(): Long\n  fun getNano(): Int\n}\nfun durationOfSeconds(seconds: Long, nano: Long): Duration\n\nclass com.squareup.wire.Instant {\n  fun getEpochSecond(): Long\n  fun getNano(): Int\n}\nfun ofEpochSecond(epochSecond: Long, nano: Long): Instant\n</code></pre> <pre><code>// Wire\nval duration: java.time.Duration = Duration.standardMinutes(15)\nval instant: java.time.Instant = Instant.now()\n\n// Protoc\nval duration: google.protobuf.Duration =\n    Duration.newBuilder()\n      .setSeconds(60 * 15)\n      .build()\nval instant: google.protobuf.Timestamp =\n    Timestamps.fromMillis(System.currentTimeMillis())\n</code></pre>"},{"location":"wire_vs_protoc/#struct","title":"Struct","text":"<p><code>google.protobuf.Struct</code> is meant mainly to represent JSON objects in code. Instead of building new types, Wire reuses Java/Kotlin native types to represent all Struct types.</p> Google Protobuf Type Wire\u2019s Java Equivalent Wire\u2019s Kotlin Equivalent <code>Struct</code> <code>Map&lt;String, ?&gt;</code> <code>Map&lt;String, ?&gt;?</code> <code>ListValue</code> <code>List&lt;?&gt;</code> <code>List&lt;?&gt;?</code> <code>Value</code> <code>Object</code> <code>Any?</code> <code>NullValue</code> <code>Void</code> <code>Nothing?</code> <p>One difference worth noting between Protoc and Wire is that Protoc can make the difference between an absent value, and a <code>null</code> value, Wire doesn\u2019t. Wire will always write <code>null</code>s in JSON objects except at the root of it.</p> <pre><code>// Wire\nval struct = mapOf(\"a\" to 1.0)\nval list = listOf(\u201cb\u201d, 2.0)\nval boolValue = true\nval nullValue = null\n\n// Protoc\nval struct: Struct =\n    Struct.newBuilder().apply {\n        putFields(\u201ca\u201d, Value.newBuilder.setNumberValue(1.0).build())\n    }\n    .build()\nval list: List =\n    ListValue.newBuilder().apply {\n        addValues(Value.newBuilder.setStringValue(\u201ca\u201d).build())\n        addValues(Value.newBuilder.setNumberValue(2.0).build())\n    }\n    .build()\nval boolValue = Value.newBuilder.setBoolValue(true).build()\nval nullValue = Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()\n</code></pre>"},{"location":"wire_vs_protoc/#wrappers","title":"Wrappers","text":"<p>Wire didn\u2019t create new types for wrappers either, each wrapper will be represented by a nullable version of the primitive type it defines. For instance <code>google.protobuf.FloatValue</code> will be represented in Java by the float boxed type <code>@Nullable Float</code>, in Kotlin by <code>Float?</code>.</p> <pre><code>// Wire\nval floatValue = 33.3f\n\n// Protoc\nval floatValue = FloatValue.newBuilder().setValue(33.3f).build()\n</code></pre>"},{"location":"wire_vs_protoc/#json","title":"JSON","text":"<p>While Proto2 didn\u2019t, Proto3 defines Protobuf serialization over JSON. Wire and Protoc are interoperable but their API are quite different. Wire offers JSON serialization over Moshi or Gson. Protoc brings its own JsonFormatter. Beware that Protoc throws an error for unknown fields, you need to configure it to opt-out of this behavior!</p> <pre><code>// Wire &amp; Moshi\nval moshi = Moshi.Builder()\n      .add(WireJsonAdapterFactory())\n      .build()\nval adapter = moshi.adapter(Pizza::class.java)\nval pizza: Pizza = ...\nval json = adapter.toJson(pizza)\nval parsedPizza = adapter.fromJson(json)\n\n// Protoc\nval pizza: PizzaOuterClass.Pizza = \u2026\nval json = JsonFormat.printer().print(value)\nval jsonParser = JsonFormat.parser().ignoringUnknownFields()\nval parsedBuilder = PizzaOuterClass.Pizza.newBuilder()\njsonParser.merge(json, parsedBuilder)\nval parsedPizza = parsedBuilder.build()\n</code></pre>"}]}