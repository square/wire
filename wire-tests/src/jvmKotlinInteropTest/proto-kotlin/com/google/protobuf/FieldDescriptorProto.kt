// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: google/protobuf/descriptor.proto
package com.google.protobuf

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

/**
 * Describes a field within a message.
 */
class FieldDescriptorProto(
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val name: String? = null,
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  @JvmField
  val number: Int? = null,
  @field:WireField(
    tag = 4,
    adapter = "com.google.protobuf.FieldDescriptorProto${'$'}Label#ADAPTER"
  )
  @JvmField
  val label: Label? = null,
  /**
   * If type_name is set, this need not be set.  If both this and type_name
   * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.google.protobuf.FieldDescriptorProto${'$'}Type#ADAPTER"
  )
  @JvmField
  val type: Type? = null,
  /**
   * For message and enum types, this is the name of the type.  If the name
   * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
   * rules are used to find the type (i.e. first the nested types within this
   * message are searched, then within the parent, on up to the root
   * namespace).
   */
  @field:WireField(
    tag = 6,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val type_name: String? = null,
  /**
   * For extensions, this is the name of the type being extended.  It is
   * resolved in the same manner as type_name.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val extendee: String? = null,
  /**
   * For numeric types, contains the original text representation of the value.
   * For booleans, "true" or "false".
   * For strings, contains the default text contents (not escaped in any way).
   * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
   * TODO(kenton):  Base-64 encode?
   */
  @field:WireField(
    tag = 7,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val default_value: String? = null,
  /**
   * If set, gives the index of a oneof in the containing type's oneof_decl
   * list.  This field is a member of that oneof.
   */
  @field:WireField(
    tag = 9,
    adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  @JvmField
  val oneof_index: Int? = null,
  /**
   * JSON name of this field. The value is set by protocol compiler. If the
   * user has set a "json_name" option on this field, that option's value
   * will be used. Otherwise, it's deduced from the field's name by converting
   * it to camelCase.
   */
  @field:WireField(
    tag = 10,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val json_name: String? = null,
  @field:WireField(
    tag = 8,
    adapter = "com.google.protobuf.FieldOptions#ADAPTER"
  )
  @JvmField
  val options: FieldOptions? = null,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<FieldDescriptorProto, FieldDescriptorProto.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.name = name
    builder.number = number
    builder.label = label
    builder.type = type
    builder.type_name = type_name
    builder.extendee = extendee
    builder.default_value = default_value
    builder.oneof_index = oneof_index
    builder.json_name = json_name
    builder.options = options
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is FieldDescriptorProto) return false
    return unknownFields == other.unknownFields
        && name == other.name
        && number == other.number
        && label == other.label
        && type == other.type
        && type_name == other.type_name
        && extendee == other.extendee
        && default_value == other.default_value
        && oneof_index == other.oneof_index
        && json_name == other.json_name
        && options == other.options
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + name.hashCode()
      result = result * 37 + number.hashCode()
      result = result * 37 + label.hashCode()
      result = result * 37 + type.hashCode()
      result = result * 37 + type_name.hashCode()
      result = result * 37 + extendee.hashCode()
      result = result * 37 + default_value.hashCode()
      result = result * 37 + oneof_index.hashCode()
      result = result * 37 + json_name.hashCode()
      result = result * 37 + options.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (name != null) result += """name=$name"""
    if (number != null) result += """number=$number"""
    if (label != null) result += """label=$label"""
    if (type != null) result += """type=$type"""
    if (type_name != null) result += """type_name=$type_name"""
    if (extendee != null) result += """extendee=$extendee"""
    if (default_value != null) result += """default_value=$default_value"""
    if (oneof_index != null) result += """oneof_index=$oneof_index"""
    if (json_name != null) result += """json_name=$json_name"""
    if (options != null) result += """options=$options"""
    return result.joinToString(prefix = "FieldDescriptorProto{", separator = ", ", postfix = "}")
  }

  fun copy(
    name: String? = this.name,
    number: Int? = this.number,
    label: Label? = this.label,
    type: Type? = this.type,
    type_name: String? = this.type_name,
    extendee: String? = this.extendee,
    default_value: String? = this.default_value,
    oneof_index: Int? = this.oneof_index,
    json_name: String? = this.json_name,
    options: FieldOptions? = this.options,
    unknownFields: ByteString = this.unknownFields
  ): FieldDescriptorProto = FieldDescriptorProto(name, number, label, type, type_name, extendee,
      default_value, oneof_index, json_name, options, unknownFields)

  class Builder : Message.Builder<FieldDescriptorProto, Builder>() {
    @JvmField
    var name: String? = null

    @JvmField
    var number: Int? = null

    @JvmField
    var label: Label? = null

    @JvmField
    var type: Type? = null

    @JvmField
    var type_name: String? = null

    @JvmField
    var extendee: String? = null

    @JvmField
    var default_value: String? = null

    @JvmField
    var oneof_index: Int? = null

    @JvmField
    var json_name: String? = null

    @JvmField
    var options: FieldOptions? = null

    fun name(name: String?): Builder {
      this.name = name
      return this
    }

    fun number(number: Int?): Builder {
      this.number = number
      return this
    }

    fun label(label: Label?): Builder {
      this.label = label
      return this
    }

    /**
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     */
    fun type(type: Type?): Builder {
      this.type = type
      return this
    }

    /**
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     */
    fun type_name(type_name: String?): Builder {
      this.type_name = type_name
      return this
    }

    /**
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     */
    fun extendee(extendee: String?): Builder {
      this.extendee = extendee
      return this
    }

    /**
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
     * TODO(kenton):  Base-64 encode?
     */
    fun default_value(default_value: String?): Builder {
      this.default_value = default_value
      return this
    }

    /**
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     */
    fun oneof_index(oneof_index: Int?): Builder {
      this.oneof_index = oneof_index
      return this
    }

    /**
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     */
    fun json_name(json_name: String?): Builder {
      this.json_name = json_name
      return this
    }

    fun options(options: FieldOptions?): Builder {
      this.options = options
      return this
    }

    override fun build(): FieldDescriptorProto = FieldDescriptorProto(
      name = name,
      number = number,
      label = label,
      type = type,
      type_name = type_name,
      extendee = extendee,
      default_value = default_value,
      oneof_index = oneof_index,
      json_name = json_name,
      options = options,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<FieldDescriptorProto> = object : ProtoAdapter<FieldDescriptorProto>(
      FieldEncoding.LENGTH_DELIMITED, 
      FieldDescriptorProto::class, 
      "type.googleapis.com/google.protobuf.FieldDescriptorProto"
    ) {
      override fun encodedSize(value: FieldDescriptorProto): Int = 
        ProtoAdapter.STRING.encodedSizeWithTag(1, value.name) +
        ProtoAdapter.INT32.encodedSizeWithTag(3, value.number) +
        Label.ADAPTER.encodedSizeWithTag(4, value.label) +
        Type.ADAPTER.encodedSizeWithTag(5, value.type) +
        ProtoAdapter.STRING.encodedSizeWithTag(6, value.type_name) +
        ProtoAdapter.STRING.encodedSizeWithTag(2, value.extendee) +
        ProtoAdapter.STRING.encodedSizeWithTag(7, value.default_value) +
        ProtoAdapter.INT32.encodedSizeWithTag(9, value.oneof_index) +
        ProtoAdapter.STRING.encodedSizeWithTag(10, value.json_name) +
        FieldOptions.ADAPTER.encodedSizeWithTag(8, value.options) +
        value.unknownFields.size

      override fun encode(writer: ProtoWriter, value: FieldDescriptorProto) {
        ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name)
        ProtoAdapter.INT32.encodeWithTag(writer, 3, value.number)
        Label.ADAPTER.encodeWithTag(writer, 4, value.label)
        Type.ADAPTER.encodeWithTag(writer, 5, value.type)
        ProtoAdapter.STRING.encodeWithTag(writer, 6, value.type_name)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.extendee)
        ProtoAdapter.STRING.encodeWithTag(writer, 7, value.default_value)
        ProtoAdapter.INT32.encodeWithTag(writer, 9, value.oneof_index)
        ProtoAdapter.STRING.encodeWithTag(writer, 10, value.json_name)
        FieldOptions.ADAPTER.encodeWithTag(writer, 8, value.options)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): FieldDescriptorProto {
        var name: String? = null
        var number: Int? = null
        var label: Label? = null
        var type: Type? = null
        var type_name: String? = null
        var extendee: String? = null
        var default_value: String? = null
        var oneof_index: Int? = null
        var json_name: String? = null
        var options: FieldOptions? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> name = ProtoAdapter.STRING.decode(reader)
            3 -> number = ProtoAdapter.INT32.decode(reader)
            4 -> try {
              label = Label.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            5 -> try {
              type = Type.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            6 -> type_name = ProtoAdapter.STRING.decode(reader)
            2 -> extendee = ProtoAdapter.STRING.decode(reader)
            7 -> default_value = ProtoAdapter.STRING.decode(reader)
            9 -> oneof_index = ProtoAdapter.INT32.decode(reader)
            10 -> json_name = ProtoAdapter.STRING.decode(reader)
            8 -> options = FieldOptions.ADAPTER.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return FieldDescriptorProto(
          name = name,
          number = number,
          label = label,
          type = type,
          type_name = type_name,
          extendee = extendee,
          default_value = default_value,
          oneof_index = oneof_index,
          json_name = json_name,
          options = options,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: FieldDescriptorProto): FieldDescriptorProto = value.copy(
        options = value.options?.let(FieldOptions.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }
  }

  enum class Type(
    override val value: Int
  ) : WireEnum {
    /**
     * 0 is reserved for errors.
     * Order is weird for historical reasons.
     */
    TYPE_DOUBLE(1),

    TYPE_FLOAT(2),

    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
     * negative values are likely.
     */
    TYPE_INT64(3),

    TYPE_UINT64(4),

    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
     * negative values are likely.
     */
    TYPE_INT32(5),

    TYPE_FIXED64(6),

    TYPE_FIXED32(7),

    TYPE_BOOL(8),

    TYPE_STRING(9),

    /**
     * Tag-delimited aggregate.
     * Group type is deprecated and not supported in proto3. However, Proto3
     * implementations should still be able to parse the group wire format and
     * treat group fields as unknown fields.
     */
    TYPE_GROUP(10),

    /**
     * Length-delimited aggregate.
     */
    TYPE_MESSAGE(11),

    /**
     * New in version 2.
     */
    TYPE_BYTES(12),

    TYPE_UINT32(13),

    TYPE_ENUM(14),

    TYPE_SFIXED32(15),

    TYPE_SFIXED64(16),

    /**
     * Uses ZigZag encoding.
     */
    TYPE_SINT32(17),

    /**
     * Uses ZigZag encoding.
     */
    TYPE_SINT64(18);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<Type> = object : EnumAdapter<Type>(
        Type::class
      ) {
        override fun fromValue(value: Int): Type? = Type.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): Type? = when (value) {
        1 -> TYPE_DOUBLE
        2 -> TYPE_FLOAT
        3 -> TYPE_INT64
        4 -> TYPE_UINT64
        5 -> TYPE_INT32
        6 -> TYPE_FIXED64
        7 -> TYPE_FIXED32
        8 -> TYPE_BOOL
        9 -> TYPE_STRING
        10 -> TYPE_GROUP
        11 -> TYPE_MESSAGE
        12 -> TYPE_BYTES
        13 -> TYPE_UINT32
        14 -> TYPE_ENUM
        15 -> TYPE_SFIXED32
        16 -> TYPE_SFIXED64
        17 -> TYPE_SINT32
        18 -> TYPE_SINT64
        else -> null
      }
    }
  }

  enum class Label(
    override val value: Int
  ) : WireEnum {
    /**
     * 0 is reserved for errors
     */
    LABEL_OPTIONAL(1),

    LABEL_REQUIRED(2),

    LABEL_REPEATED(3);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<Label> = object : EnumAdapter<Label>(
        Label::class
      ) {
        override fun fromValue(value: Int): Label? = Label.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): Label? = when (value) {
        1 -> LABEL_OPTIONAL
        2 -> LABEL_REQUIRED
        3 -> LABEL_REPEATED
        else -> null
      }
    }
  }
}
