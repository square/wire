/*
 * Copyright 2013 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.wire;

import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.EnumType;
import com.squareup.protoparser.ExtendDeclaration;
import com.squareup.protoparser.MessageType;
import com.squareup.protoparser.Option;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.Type;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;
import javax.lang.model.element.Modifier;

import static com.squareup.protoparser.MessageType.Field;
import static com.squareup.wire.Message.Datatype;
import static com.squareup.wire.Message.Label;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

/** Compiler for Wire protocol buffers. */
public class WireCompiler {

  private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
  private static final Map<String, String> JAVA_TYPES = new LinkedHashMap<String, String>();
  private static final Set<String> JAVA_KEYWORDS = new LinkedHashSet<String>(
      Arrays.asList("abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
          "class", "const", "continue", "default", "do", "double", "else", "enum", "extends",
          "final", "finally", "float", "for", "goto", "if", "implements", "import", "instanceof",
          "int", "interface", "long", "native", "new", "package", "private", "protected", "public",
          "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
          "throw", "throws", "transient", "try", "void", "volatile", "while"));
  private static final String PROTO_PATH_FLAG = "--proto_path=";
  private static final String JAVA_OUT_FLAG = "--java_out=";
  private static final String FILES_FLAG = "--files=";
  private static final String ROOTS_FLAG = "--roots=";
  private static final String URL_CHARS = "[-!#$%&'()*+,./0-9:;=?@A-Z\\[\\]_a-z~]";
  private static final String INDENT = "  ";
  private static final String LINE_WRAP_INDENT = "    ";
  static {
    JAVA_TYPES.put("bool", "Boolean");
    JAVA_TYPES.put("bytes", "ByteString");
    JAVA_TYPES.put("double", "Double");
    JAVA_TYPES.put("float", "Float");
    JAVA_TYPES.put("fixed32", "Integer");
    JAVA_TYPES.put("fixed64", "Long");
    JAVA_TYPES.put("int32", "Integer");
    JAVA_TYPES.put("int64", "Long");
    JAVA_TYPES.put("sfixed32", "Integer");
    JAVA_TYPES.put("sfixed64", "Long");
    JAVA_TYPES.put("sint32", "Integer");
    JAVA_TYPES.put("sint64", "Long");
    JAVA_TYPES.put("string", "String");
    JAVA_TYPES.put("uint32", "Integer");
    JAVA_TYPES.put("uint64", "Long");
  }
  private static final String CODE_GENERATED_BY_WIRE =
      "Code generated by Wire protocol buffer compiler, do not edit.";

  private final String repoPath;
  private final List<String> sourceFileNames;
  private final IO io;
  private final Set<String> typesToEmit = new LinkedHashSet<String>();
  private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
  private final Set<String> enumTypes = new LinkedHashSet<String>();
  private final Map<String, String> enumDefaults = new LinkedHashMap<String, String>();
  private final Map<String, ExtensionInfo> extensionInfo =
      new LinkedHashMap<String, ExtensionInfo>();
  private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();
  private final String outputDirectory;
  private ProtoFile protoFile;
  private String sourceFileName;
  private String protoFileName;
  private String typeBeingGenerated = "";
  private JavaWriter writer;

  /**
   * Runs the compiler. Usage:
   *
   * <pre>
   * java WireCompiler --proto_path=<path> --java_out=<path> [--files=<protos.include>]
   *     [--roots=<message_name>[,<message_name>...]] [file [file...]]
   * </pre>
   *
   * If the {@code --roots} flag is present, its argument must be a comma-separated list
   * of fully-qualified message or enum names. The output will be limited to those messages
   * and enums that are (transitive) dependencies of the listed names.
   */
  public static void main(String... args) throws Exception {
    String protoPath = null;
    String javaOut = null;
    List<String> sourceFileNames = new ArrayList<String>();
    List<String> roots = new ArrayList<String>();

    int index = 0;
    while (index < args.length) {
      if (args[index].startsWith(PROTO_PATH_FLAG)) {
        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
      } else if (args[index].startsWith(FILES_FLAG)) {
        File files = new File(args[index].substring(FILES_FLAG.length()));
        String[] fileNames = new Scanner(files, "UTF-8").useDelimiter("\\A").next().split("\n");
        sourceFileNames.addAll(Arrays.asList(fileNames));
      } else if (args[index].startsWith(ROOTS_FLAG)) {
        roots.addAll(Arrays.asList(args[index].substring(ROOTS_FLAG.length()).split(",")));
      } else {
        sourceFileNames.add(args[index]);
      }
      index++;
    }
    if (javaOut == null) {
      System.err.println("Must specify " + JAVA_OUT_FLAG + " flag");
      System.exit(1);
    }
    if (protoPath == null) {
      protoPath = System.getProperty("user.dir");
      System.err.println(PROTO_PATH_FLAG + " flag not specified, using current dir " + protoPath);
    }
    WireCompiler wireCompiler = new WireCompiler(protoPath, sourceFileNames, roots, javaOut);
    wireCompiler.compile();
  }

  public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
      String outputDirectory) {
    this(protoPath, sourceFileNames, roots, outputDirectory, new FileIO());
  }

   WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
      String outputDirectory, IO io) {
    this.repoPath = protoPath;
    this.typesToEmit.addAll(roots);
    this.sourceFileNames = sourceFileNames;
    this.outputDirectory = outputDirectory;
    this.io = io;
  }

  public void compile() throws IOException {
    Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();

    for (String sourceFilename : sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      ProtoFile protoFile = io.parse(sourcePath);
      parsedFiles.put(sourcePath, protoFile);

      loadSymbols(protoFile);
    }

    if (!typesToEmit.isEmpty()) {
      System.out.println("Analyzing dependencies of root types.");
      findDependencies(parsedFiles.values());
    }

    for (Map.Entry<String, ProtoFile> entry : parsedFiles.entrySet()) {
      this.sourceFileName = entry.getKey();
      this.protoFile = entry.getValue();
      this.protoFileName = protoFileName(protoFile.getFileName());
      System.out.println("Compiling proto source file " + sourceFileName);
      compileOne();
    }
  }

  private void compileOne() throws IOException {
    typeBeingGenerated = "";

    if (hasExtends()) {
      try {
        writer = io.getJavaWriter(outputDirectory, protoFile.getJavaPackage(),
            "Ext_" + protoFileName);
        emitExtensionClass();
      } finally {
        writer.close();
      }
    }

    for (Type type : protoFile.getTypes()) {
      if (shouldEmitType(type.getFullyQualifiedName())) {
        String savedType = typeBeingGenerated;
        typeBeingGenerated += type.getName() + ".";
        emitMessageClass(type);
        typeBeingGenerated = savedType;
      }
    }
  }

  private boolean shouldEmitType(String name) {
    return typesToEmit.isEmpty() || typesToEmit.contains(name);
  }

  private void findDependencies(Collection<ProtoFile> protoFiles) throws IOException {
    Set<String> loadedDependencies = new LinkedHashSet<String>();
    int count = typesToEmit.size();
    while (true) {
      for (ProtoFile protoFile : protoFiles) {
        findDependenciesHelper(protoFile, loadedDependencies);
      }
      int newCount = typesToEmit.size();
      if (newCount == count) {
        break;
      }
      count = newCount;
    }
  }

  private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
      throws IOException {
    // Load symbols from imports
    for (String dependency : protoFile.getDependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        ProtoFile dependencyFile = io.parse(dep);
        loadSymbols(dependencyFile);
        loadedDependencies.add(dependency);
      }
    }

    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String typeName = extend.getFullyQualifiedName();
      typesToEmit.add(typeName);
      for (Field field : extend.getFields()) {
        // FIXME: we need to determine the fully-qualified name of the extension field.
        // Perhaps this should be handled by protoparser.
        // For now, just prepend the proto file's package name
        String fieldTypeName = prefixWithPackageName(protoFile, field.getType());
        typesToEmit.add(fieldTypeName);
      }
    }

    addDependencies(protoFile.getTypes(), protoFile.getJavaPackage() + ".");
  }

  /** Expands the set of types to emit to include types of fields of current emittable types. */
  private void addDependencies(List<Type> types, String javaPrefix) {
    for (Type type : types) {
      String name = type.getName();
      String fqName = type.getFullyQualifiedName();
      if (type instanceof MessageType && typesToEmit.contains(fqName)) {
        for (MessageType.Field field : ((MessageType) type).getFields()) {
          String fieldType = field.getType();
          if (!isScalar(fieldType)) {
            String fqFieldType = fullyQualifiedName((MessageType) type, field.getType());
            addDependencyBranch(fqFieldType);
          }
        }
      }
      addDependencies(type.getNestedTypes(), javaPrefix + name + ".");
    }
  }

  /** Adds a type name and all its ancestors to the set of emittable types. */
  private void addDependencyBranch(String name) {
    while (typeIsComplete(name)) {
      typesToEmit.add(name);
      name = removeTrailingSegment(name);
    }
  }

  private String removeTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? "" :  name.substring(0, index);
  }

  private enum LoadSymbolsPass {
    LOAD_TYPES, LOAD_FIELDS
  }

  private void loadSymbols(ProtoFile protoFile) throws IOException {
    // Make two passes through the input files. In the first pass we collect message and enum
    // types, and in the second pass we collect field types.
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_TYPES);
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_FIELDS);
  }

  // Call with pass == LOAD_TYPES, then pass == LOAD_FIELDS
  private void loadSymbolsHelper(ProtoFile protoFile, Set<String> loadedDependencies,
      LoadSymbolsPass pass) throws IOException {
    // Load symbols from imports
    for (String dependency : protoFile.getDependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        ProtoFile dependencyFile = io.parse(dep);
        loadSymbolsHelper(dependencyFile, loadedDependencies, pass);
        loadedDependencies.add(dependency);
      }
    }

    addTypes(protoFile.getTypes(), protoFile.getJavaPackage() + ".", pass);
    addExtensions(protoFile);
  }

  private void addExtensions(ProtoFile protoFile) {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        String type = javaName(protoFile, null, fieldType);
        if (type == null) {
          type = javaName(protoFile, null, prefixWithPackageName(protoFile, fieldType));
        }
        type = shortenJavaName(protoFile, type);
        String fqName = prefixWithPackageName(protoFile, field.getName());
        String fqType;

        boolean isScalar = isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fullyQualifiedName(protoFile, null, fieldType));
        if (isScalar) {
          type = field.getType();
          fqType = type;
        } else if (isEnum) {
          // Store fully-qualified name for enumerations so we can identify them later
          type = fullyQualifiedName(protoFile, null, fieldType);
          fqType = type;
        } else {
          fqType = fullyQualifiedName(protoFile, null, fieldType);
        }

        String location = protoFileName(protoFile.getFileName());
        String fqLocation = protoFile.getJavaPackage() + ".Ext_" + location;
        ExtensionInfo info = new ExtensionInfo(type, fqType, location, fqLocation,
            field.getLabel());
        extensionInfo.put(fqName, info);
      }
    }
  }

  private void addTypes(List<Type> types, String javaPrefix, LoadSymbolsPass pass) {
    for (Type type : types) {
      String name = type.getName();
      if (pass == LoadSymbolsPass.LOAD_TYPES) {
        String fqName = type.getFullyQualifiedName();
        javaSymbolMap.put(fqName, javaPrefix + name);
        if (type instanceof EnumType) {
          enumTypes.add(fqName);
          enumDefaults.put(fqName, ((EnumType) type).getValues().get(0).getName());
        }
      } else if (type instanceof MessageType) {
        addFields((MessageType) type);
      }
      addTypes(type.getNestedTypes(), javaPrefix + name + ".", pass);
    }
  }

  private void addFields(MessageType messageType) {
    for (MessageType.Field field : messageType.getFields()) {
      String fieldType = field.getType();
      String fqMessageName = messageType.getFullyQualifiedName();
      String key = fqMessageName + "$" + field.getName();
      fieldMap.put(key, new FieldInfo(isScalar(fieldType)
          ? fieldType : fullyQualifiedName(messageType, fieldType), field.getLabel()));
    }
  }

  private String getJavaFieldType(ProtoFile protoFile, MessageType messageType, Field field) {
    String javaName = javaName(protoFile, messageType, field.getType());
    if (isRepeated(field)) javaName = "List<" + javaName + ">";
    return javaName;
  }

  private String javaName(ProtoFile protoFile, MessageType messageType, String type) {
    String scalarType = scalarType(type);
    return scalarType != null
        ? scalarType : shortenJavaName(protoFile,
            javaName(fullyQualifiedName(protoFile, messageType, type)));
  }

  private String fullyQualifiedName(ProtoFile protoFile, MessageType messageType, String type) {
    if (typeIsComplete(type)) {
      return type;
    } else {
      String prefix = messageType == null
          ? protoFile.getPackageName() : messageType.getFullyQualifiedName();
      while (!prefix.isEmpty()) {
        String fqname = prefix + "." + type;
        if (typeIsComplete(fqname)) return fqname;
        prefix = removeTrailingSegment(prefix);
      }
    }
    throw new RuntimeException("Unknown type " + type + " in message "
        + (messageType == null ? "<unknown>" : messageType.getName()));
  }


  private String shortenJavaName(ProtoFile protoFile, String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaTypeBeingGenerated = protoFile.getJavaPackage() + "." + typeBeingGenerated;
    if (fullyQualifiedName.startsWith(javaTypeBeingGenerated)) {
      return fullyQualifiedName.substring(javaTypeBeingGenerated.length());
    }

    // Dependencies in javaSymbolMap are already imported.
    for (String javaSymbol : javaSymbolMap.values()) {
      if (fullyQualifiedName.startsWith(javaSymbol)) {
        // omit package part
        String pkgPrefix = getPackageFromFullyQualifiedJavaName(fullyQualifiedName) + '.';
        return fullyQualifiedName.substring(pkgPrefix.length());
      }
    }

    return fullyQualifiedName;
  }

  private String protoFileName(String path) {
    int slashIndex = path.lastIndexOf('/');
    if (slashIndex != -1) {
      path = path.substring(slashIndex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  private void emitMessageClass(Type type) throws IOException {
    try {
      writer = io.getJavaWriter(outputDirectory, protoFile.getJavaPackage(), type.getName());
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(protoFile.getJavaPackage());

      List<Type> types = new ArrayList<Type>();
      getTypes(type, types);
      boolean hasMessage = hasMessage(types);
      boolean hasExtensions = hasExtensions(Arrays.asList(type));

      Set<String> imports = new LinkedHashSet<String>();
      if (hasMessage) {
        imports.add("com.squareup.wire.Message");
      }
      if (hasMessage || hasExtensions) {
        if (hasFields(type)) {
          imports.add("com.squareup.wire.ProtoField");
        }
      }
      if (hasBytesField(types)) {
        imports.add("com.squareup.wire.ByteString");
      }
      if (hasEnum(types)) {
        imports.add("com.squareup.wire.ProtoEnum");
      }
      if (hasRepeatedField(types)) {
        imports.add("java.util.Collections");
        imports.add("java.util.List");
      }
      if (hasExtensions) {
        imports.add("com.squareup.wire.ExtendableMessage");
        imports.add("com.squareup.wire.Extension");
      }
      if (hasMessageOption(types)) {
        imports.add("com.google.protobuf.MessageOptions");
      }
      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(type, externalTypes);

      Map<String, ?> optionsMap = null;
      if (type instanceof MessageType) {
        optionsMap = createOptionsMap((MessageType) type);
      }
      if (optionsMap != null) {
        getOptionTypes(optionsMap, externalTypes);
      }

      imports.addAll(externalTypes);
      writer.emitImports(imports);

      // Emit static imports for Datatype. and Label. enums
      Collection<Datatype> datatypes = new TreeSet<Datatype>(Datatype.ORDER_BY_NAME);
      Collection<Label> labels = new TreeSet<Label>(Label.ORDER_BY_NAME);
      getDatatypesAndLabels(type, datatypes, labels);
      // No need to emit 'label = OPTIONAL' since it is the default
      labels.remove(Label.OPTIONAL);

      if (!datatypes.isEmpty() || !labels.isEmpty()) {
        writer.emitEmptyLine();
      }
      for (Datatype datatype : datatypes) {
        writer.emitStaticImports("com.squareup.wire.Message.Datatype." + datatype.toString());
      }
      for (Label label : labels) {
        writer.emitStaticImports("com.squareup.wire.Message.Label." + label.toString());
      }

      emitType(type, protoFile.getPackageName() + ".", optionsMap, true);
    } finally {
      writer.close();
    }
  }

  @SuppressWarnings("unchecked")
  private void getOptionTypes(Map<String, ?> optionsMap, List<String> types) {
    for (Map.Entry<String, ?> entry : optionsMap.entrySet()) {
      ExtensionInfo info = extensionInfo.get(entry.getKey());
      if (info != null && !info.fqLocation.startsWith(protoFile.getJavaPackage())) {
        types.add(info.fqLocation);
      }

      if ("@type".equals(entry.getKey())) {
        String type = (String) entry.getValue();
        String javaName = javaName(type);
        if (fullyQualifiedNameIsOutsidePackage(javaName)) {
          types.add(javaName);
        }
      } else if (entry.getValue() instanceof List) {
        for (Object objectValue : (List<?>) entry.getValue()) {
          if (objectValue instanceof Map) {
            getOptionTypes((Map<String, ?>) objectValue, types);
          }
        }
      } else if (entry.getValue() instanceof Map) {
        getOptionTypes((Map<String, ?>) entry.getValue(), types);
      }
    }
  }

  private boolean hasMessageOption(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType && !((MessageType) type).getOptions().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private void getTypes(Type parent, List<Type> types) {
    types.add(parent);
    for (Type nestedType : parent.getNestedTypes()) {
      getTypes(nestedType, types);
    }
  }

  private void getExternalTypes(Type parent, List<String> types) {
    if (parent instanceof MessageType) {
      MessageType messageType = (MessageType) parent;
      for (Field field : messageType.getFields()) {
        String fqName = fullyQualifiedJavaName(messageType, field.getType());
        if (fullyQualifiedNameIsOutsidePackage(fqName)) {
          types.add(fqName);
        }
      }
    }
    for (Type nestedType : parent.getNestedTypes()) {
      getExternalTypes(nestedType, types);
    }
  }

  private String getPackageFromFullyQualifiedJavaName(String fqName) {
    while (javaSymbolMap.containsValue(fqName)) {
      fqName = removeTrailingSegment(fqName);
    }
    return fqName;
  }

  private List<String> getExtensionTypes() {
    List<String> extensionClasses = new ArrayList<String>();
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String fqName = fullyQualifiedJavaName(null, extend.getFullyQualifiedName());
      if (fullyQualifiedNameIsOutsidePackage(fqName)) {
        extensionClasses.add(fqName);
      }
      for (Field field : extend.getFields()) {
        String fqFieldType = fullyQualifiedJavaName(null, field.getType());
        if (fullyQualifiedNameIsOutsidePackage(fqFieldType)) {
          extensionClasses.add(fqFieldType);
        }
      }
    }
    return extensionClasses;
  }

  private boolean fullyQualifiedNameIsOutsidePackage(String fqName) {
    return fqName != null
        && !protoFile.getJavaPackage().equals(getPackageFromFullyQualifiedJavaName(fqName));
  }

  private boolean hasExtends() {
    return !protoFile.getExtendDeclarations().isEmpty();
  }

  private void emitExtensionClass() throws IOException {
    writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
    writer.emitSingleLineComment("Source file: %s", sourceFileName);
    writer.emitPackage(protoFile.getJavaPackage());

    Set<String> imports = new LinkedHashSet<String>();
    if (hasByteStringExtension()) {
      imports.add("com.squareup.wire.ByteString");
    }
    imports.add("com.squareup.wire.Extension");
    if (hasRepeatedExtension()) {
      imports.add("java.util.List");
    }
    imports.addAll(getExtensionTypes());
    writer.emitImports(imports);
    writer.emitEmptyLine();

    String className = "Ext_" + protoFileName;
    writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
    writer.emitEmptyLine();

    // Private no-args constructor
    writer.beginMethod(null, className, EnumSet.of(PRIVATE));
    writer.endMethod();
    writer.emitEmptyLine();

    emitExtensions();
    writer.endType();
  }

  private void emitExtensions() throws IOException {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String fullyQualifiedName = extend.getFullyQualifiedName();
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        String type = javaName(null, fieldType);
        if (type == null) {
          type = javaName(null, prefixWithPackageName(fieldType));
        }
        type = shortenJavaName(type);
        String initialValue;
        String className = writer.compressType(name);
        String extensionName = field.getName();
        String fqName = prefixWithPackageName(field.getName());
        int tag = field.getTag();

        boolean isScalar = isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fullyQualifiedName(null, fieldType));
        String labelString = getLabelString(field, isEnum);
        if (isScalar) {
          initialValue = String.format("Extension%n"
              + "%1$s.%2$sExtending(%3$s.class)%n"
              + "%1$s.setName(\"%4$s\")%n"
              + "%1$s.setTag(%5$d)%n"
              + "%1$s.build%6$s()", INDENT + LINE_WRAP_INDENT, field.getType(), className, fqName,
              tag, labelString);
        } else if (isEnum) {
          initialValue = String.format("Extension%n"
              + "%1$s.enumExtending(%2$s.class, %3$s.class)%n"
              + "%1$s.setName(\"%4$s\")%n"
              + "%1$s.setTag(%5$d)%n"
              + "%1$s.build%6$s()", INDENT + LINE_WRAP_INDENT, type, className, fqName, tag,
              labelString);
        } else {
          initialValue = String.format("Extension%n"
              + "%1$s.messageExtending(%2$s.class, %3$s.class)%n"
              + "%1$s.setName(\"%4$s\")%n"
              + "%1$s.setTag(%5$d)%n"
              + "%1$s.build%6$s()", INDENT + LINE_WRAP_INDENT, type, className, fqName, tag,
              labelString);
        }

        if (isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", extensionName,
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  private String prefixWithPackageName(ProtoFile protoFile, String name) {
    return protoFile.getPackageName() + "." + name;
  }

  private String prefixWithPackageName(String name) {
    return prefixWithPackageName(protoFile, name);
  }

  private String getLabelString(Field field, boolean isEnum) {
    switch (field.getLabel()) {
      case OPTIONAL: return "Optional";
      case REQUIRED: return "Required";
      case REPEATED:
        return isPacked(field, isEnum) ? "Packed" : "Repeated";
      default:
        throw new RuntimeException("Unknown extension label \"" + field.getLabel() + "\"");
    }
  }

  private boolean hasByteStringExtension() {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        if ("bytes".equals(fieldType)) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasRepeatedExtension() {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        if (field.getLabel() == MessageType.Label.REPEATED) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasExtensions(MessageType messageType) {
    return !messageType.getExtensions().isEmpty();
  }

  private void emitType(Type type, String currentType, Map<String, ?> optionsMap, boolean topLevel)
      throws IOException {
    writer.emitEmptyLine();
    if (type instanceof MessageType) {
      MessageType messageType = (MessageType) type;
      Set<Modifier> modifiers = EnumSet.of(PUBLIC, FINAL);
      if (!topLevel) {
        modifiers.add(STATIC);
      }
      String name = messageType.getName();
      emitDocumentation(messageType.getDocumentation());
      writer.beginType(name, "class", modifiers,
          hasExtensions(messageType) ? "ExtendableMessage<" + name + ">" : "Message");
      emitMessageOptions(optionsMap);
      emitMessageDefaults(messageType);
      emitMessageFields(messageType);
      emitMessageConstructor(messageType);
      emitMessageEquals(messageType);
      emitMessageHashCode(messageType);
      emitBuilder(messageType);

      for (Type nestedType : type.getNestedTypes()) {
        emitType(nestedType, currentType + nestedType.getName() + ".", optionsMap, false);
      }

      writer.endType();
    } else if (type instanceof EnumType) {
      EnumType enumType = (EnumType) type;
      writer.beginType(enumType.getName(), "enum", EnumSet.of(PUBLIC));
      for (EnumType.Value value : enumType.getValues()) {
        emitDocumentation(value.getDocumentation());
        writer.emitAnnotation(ProtoEnum.class, value.getTag());
        writer.emitEnumValue(value.getName());
      }
      writer.endType();
    }
  }

  private void emitDocumentation(String documentation) throws IOException {
    if (hasDocumentation(documentation)) {
      writer.emitJavadoc(sanitizeJavadoc(documentation));
    }
  }

  /**
   * A grab-bag of fixes for things that can go wrong when converting to javadoc.
   */
  private String sanitizeJavadoc(String documentation) {
    // JavaWriter will pass the doc through String.format, so escape all '%' chars
    documentation = documentation.replace("%", "%%");
    // Remove trailing whitespace
    documentation = documentation.replaceAll("\\s+\n", "\n");
    // Rewrite '@see <url>' to use an html anchor tag
    documentation =
        documentation.replaceAll("@see (http:" + URL_CHARS + "+)", "@see <a href=\"$1\">$1</a>");
    return documentation;
  }

  private void emitMessageOptions(Map<String, ?> optionsMap) throws IOException {
    if (optionsMap != null) {
      StringBuilder sb = new StringBuilder();
      sb.append("new MessageOptions.Builder()");
      for (Map.Entry<String, ?> entry : optionsMap.entrySet()) {
        String fqName = entry.getKey();
        ExtensionInfo info = extensionInfo.get(fqName);
        sb.append(String.format("%n%s.setExtension(Ext_%s.%s, %s)", INDENT + LINE_WRAP_INDENT,
            info.location, getTrailingSegment(fqName),
            createOptionInitializer(entry.getValue(), "", "", info.fqType, false, 1)));
      }
      sb.append("\n").append(INDENT).append(LINE_WRAP_INDENT).append(".build()");
      writer.emitEmptyLine();
      writer.emitField("MessageOptions", "MESSAGE_OPTIONS", EnumSet.of(PUBLIC, STATIC, FINAL),
          sb.toString());
    }
  }

  private String getTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(index + 1);
  }

  private Map<String, ?> createOptionsMap(MessageType type) {
    List<Option> options = type.getOptions();
    if (options.isEmpty()) {
      return null;
    }

    Map<String, Object> map = new LinkedHashMap<String, Object>();
    for (Option option : options) {
      insertOption(option.getName(), option.getValue(), type.getFullyQualifiedName(), map);
    }
    return map;
  }

  /**
   * Builds a nested map from a set of options. Each level of the map corresponding to
   * a message has an extra key "class" whose value is the Java type name for the
   * message. For example, consider the following options:
   *
   * <pre>
   *
   * package mypackage;
   *
   * extend google.protobuf.MessageOptions {
   *   optional FooBar my_message_option_one = 50001;
   *   optional float my_message_option_two = 50002;
   *   optional FooBar my_message_option_three = 50003;
   *   optional FooBar.FooBarBazEnum my_message_option_four = 50004;
   * }
   *
   * message MessageWithOptions {
   *   option (my_message_option_one).foo = 1234;
   *   option (my_message_option_one.bar) = "5678";
   *   option (my_message_option_one.baz.value) = BAZ;
   *   option (my_message_option_one).qux = 18446744073709551615;
   *   option (my_message_option_one).fred = 123.0;
   *   option (my_message_option_one).fred = 321.0;
   *   option (my_message_option_one).daisy = 456.0;
   *   option (my_message_option_two) = 91011.0;
   *   option (my_message_option_three) = { foo: 11, bar: "22", baz: { value: BAR }};
   * }
   *
   * message FooBar {
   *   optional int32 foo = 1;
   *   optional string bar = 2;
   *   optional Nested baz = 3;
   *   optional uint64 qux = 4;
   *   repeated float fred = 5;
   *   optional double daisy = 6;
   *
   *   message Nested {
   *    optional FooBarBazEnum value = 1;
   *   }
   *
   *   enum FooBarBazEnum {
   *    FOO = 1;
   *    BAR = 2;
   *    BAZ = 3;
   *   }
   * }
   * </pre>
   *
   * The generated map has the following structure:
   *
   * <pre>
   * {
   *   "my_message_option_one": {
   *     "@type": "mypackage.FooBar",
   *     "foo": "1234",
   *     "bar": "\"5678\"",
   *     "baz": {
   *       "@type": "FooBar.FooBarBazEnum",
   *       "value": "FooBar.FooBarBazEnum.BAZ"
   *     }
   *     "qux": "-1L", // note: wrapped to signed 64-bits
   *     "fred": ["123.0F", "321.0F"]
   *     "daisy": "456.0D"
   *   }
   *   "my_message_option_two": "91011.0",
   *   "my_message_option_three": {
   *     "@type": "mypackage.FooBar",
   *     "foo": "11",
   *     "bar": "\"22\"",
   *     "baz": {
   *       "@type": "mypackage.FooBar.FooBarBazEnum",
   *       "value": "mypackage.FooBar.FooBarBazEnum.BAR"
   *     }
   *   }
   * }
   * </pre>
   */
  @SuppressWarnings("unchecked")
  private void insertOption(String name, Object value, String enclosingType,
      Map<String, Object> map) {
    // Append the current package name if no prefix of the given name matches a known extension
    String fqName = getExtensionPrefix(name);
    if (fqName.isEmpty()) {
      name = prefixWithPackageName(name);
    }
    insertOptionHelper(name, value, enclosingType, map);
  }

  private String getExtensionPrefix(String name) {
    int endIndex = name.length();
    String fqName;
    while (endIndex != -1) {
      fqName = name.substring(0, endIndex);
      if (extensionInfo.containsKey(fqName)) return fqName;
      endIndex = name.lastIndexOf('.', endIndex - 1);
    }
    return "";
  }

  @SuppressWarnings("unchecked")
  private void insertOptionHelper(String name, Object value, String enclosingType,
      Map<String, Object> map) {
    // Strip square brackets (indicating an extension) from the option name
    name = stripSquareBrackets(name);

    // If the option name has dots in it after the longest prefix that is a known extension name,
    // break off the first level and recurse
    String fqName = getExtensionPrefix(name);
    int firstDotAfterExtensionIndex = name.indexOf('.', fqName.length());
    if (firstDotAfterExtensionIndex != -1) {
      String prefix = name.substring(0, firstDotAfterExtensionIndex);
      String suffix = name.substring(firstDotAfterExtensionIndex + 1);
      String fieldType = getFieldType(enclosingType, prefix);
      insertOptionHelper(prefix, new Option(suffix, value), fieldType, map);
      return;
    }

    ExtensionInfo info = getExtensionInfo(name);

    // Deal with names that start with a suffix of the package name
    if (info == null && protoFile.getPackageName().endsWith("." + name)
        && value instanceof Option) {
      name = prefixWithPackageName(((Option) value).getName());
      info = extensionInfo.get(name);
      value = ((Option) value).getValue();
    }

    if (info != null) {
      enclosingType = info.fqType;
    }

    // Place simple entries into the map, recurse on nested entries
    String fieldType = info == null ? getFieldType(enclosingType, name) : info.type;
    if (fieldType == null) {
      fieldType = enclosingType;
    }

    if (value instanceof String) {
      MessageType.Label fieldLabel = getFieldLabel(enclosingType, name);
      if (info != null) {
        fieldLabel = info.label;
      }
      insertStringOption(name, (String) value, map, fieldType, fieldLabel);
    } else if (value instanceof List) {
      insertListOption(name, (List<?>) value, enclosingType, map, fieldType);
    } else if (value instanceof Option) {
      insertOptionOption(name, (Option) value, enclosingType, map);
    } else if (value instanceof Map) {
      insertMapOption(name, (Map<String, ?>) value, enclosingType, map);
    } else {
      throw new RuntimeException("value is not an Option, String, List, or Map");
    }
  }

  private String stripSquareBrackets(String name) {
    int lastIndex = name.length() - 1;
    if (name.charAt(0) == '[' && name.charAt(lastIndex) == ']') {
      name = name.substring(1, lastIndex);
      if (!name.contains(".")) {
        name = prefixWithPackageName(name);
      }
    }
    return name;
  }

  @SuppressWarnings("unchecked")
  private void insertStringOption(String name, String value, Map<String, Object> map,
      String fieldType, MessageType.Label fieldLabel) {
    value = getOptionInitializer(value, fieldType);
    if (fieldLabel == MessageType.Label.REPEATED) {
      List<String> list = (List<String>) map.get(name);
      if (list == null) {
        list = new ArrayList<String>();
        map.put(name, list);
      }
      list.add(value);
    } else {
      map.put(name, value);
    }
  }

  @SuppressWarnings("unchecked")
  private void insertListOption(String name, List<?> value, String enclosingType,
      Map<String, Object> map, String fieldType) {
    List<Object> valueList = new ArrayList<Object>();
    for (Object objectValue : value) {
      if (objectValue instanceof String) {
        String stringValue = getOptionInitializer((String) objectValue, fieldType);
        valueList.add(stringValue);
      } else if (objectValue instanceof Map) {
        Map<String, Object> entryMap = new LinkedHashMap<String, Object>();
        entryMap.put("@type", enclosingType);
        insertOptionsFromMap(enclosingType, (Map<String, ?>) objectValue, entryMap);
        valueList.add(entryMap);
      } else {
        throw new RuntimeException("List contains " + objectValue.getClass().getName()
            + ", not String or Map");
      }
    }
    map.put(name, valueList);
  }

  private void insertOptionOption(String name, Option value, String enclosingType,
      Map<String, Object> map) {
    Map<String, Object> entryMap = getOrCreateFromMap(map, name);
    entryMap.put("@type", enclosingType);

    String nestedName = value.getName();
    String fieldType = getFieldType(enclosingType, nestedName);
    // Only rewrite enum initializers, others will be rewritten at the final insertion level
    Object val = qualifyEnum(enclosingType, nestedName, fieldType, value.getValue());
    insertOptionHelper(nestedName, val, enclosingType, entryMap);
  }

  private void insertMapOption(String name, Map<String, ?> value, String enclosingType,
      Map<String, Object> map) {
    Map<String, Object> entryMap = getOrCreateFromMap(map, name);
    entryMap.put("@type", enclosingType);
    insertOptionsFromMap(enclosingType, value, entryMap);
  }

  @SuppressWarnings("unchecked")
  private Map<String, Object> getOrCreateFromMap(Map<String, Object> map, String name) {
    Object entry = map.get(name);
    if (entry == null) {
      entry = new LinkedHashMap<String, Object>();
      map.put(name, entry);
    }
    return (Map<String, Object>) entry;
  }

  private ExtensionInfo getExtensionInfo(String name) {
    ExtensionInfo info = extensionInfo.get(name);
    if (info == null) {
      info = extensionInfo.get(prefixWithPackageName(name));
    }
    return info;
  }

  private void insertOptionsFromMap(String enclosingType, Map<String, ?> inputMap,
      Map<String, Object> outputMap) {
    for (Map.Entry<String, ?> valueEntry : inputMap.entrySet()) {
      String nestedName = valueEntry.getKey();
      String fieldType = getFieldType(enclosingType, nestedName);
      Object val = qualifyEnum(enclosingType, nestedName, fieldType, valueEntry.getValue());
      insertOptionHelper(nestedName, val, fieldType, outputMap);
    }
  }

  private String getOptionInitializer(String stringValue, String fieldType) {
    if (isScalar(fieldType)) {
      String javaTypeName = scalarType(fieldType);
      return getInitializerForType(stringValue, javaTypeName);
    } else if (isEnum(fieldType)) {
      String shortName = shortenJavaName(javaName(fieldType));
      return shortName + "." + getTrailingSegment(stringValue);
    } else {
      return stringValue;
    }
  }

  private String getFieldType(String enclosingType, String nestedName) {
    FieldInfo fieldInfo = fieldMap.get(enclosingType + "$" + nestedName);
    return getFieldType(fieldInfo);
  }

  private MessageType.Label getFieldLabel(String enclosingType, String nestedName) {
    FieldInfo fieldInfo = fieldMap.get(enclosingType + "$" + nestedName);
    return fieldInfo == null ? null : fieldInfo.label;
  }

  private Object qualifyEnum(String enclosingType, String optionValueName, String fieldType,
      Object value) {
    if (isEnum(getFieldType(enclosingType, optionValueName))) {
      return fieldType + "." + value;
    }
    return value;
  }

  @SuppressWarnings("unchecked")
  private String createOptionInitializer(Object listOrMap, String parentType,
      String parentField, String fieldType, boolean skipAsList, int level) {
    level++;

    StringBuilder sb = new StringBuilder();
    if (listOrMap instanceof Map) {
      Map<String, Object> map = (Map<String, Object>) listOrMap;
      String fullyQualifiedName = javaName(fieldType);
      String dollarName = parentType + "$" + parentField;
      FieldInfo fieldInfo = fieldMap.get(dollarName);
      boolean emitAsList = !skipAsList && isRepeated(fieldInfo);
      if (emitAsList) {
        sb.append("asList(");
      }
      String shortName = shortenJavaName(fullyQualifiedName);
      sb.append("new ").append(shortName).append(".Builder()");
      for (Map.Entry<String, ?> entry : map.entrySet()) {
        String key = entry.getKey();
        if (isMetadata(key)) {
          continue;
        }
        sb.append("\n  ");
        indent(sb, level);
        sb.append(".");

        ExtensionInfo extension = extensionInfo.get(key);
        if (extension != null) {
          key = getTrailingSegment(key);
          sb.append(String.format("setExtension(Ext_%s.%s, ", extension.location, key));
        } else {
          sb.append(key).append("(");
        }

        FieldInfo info = fieldMap.get(fieldType + "$" + key);
        String nestedFieldType;
        if (info == null) {
          ExtensionInfo extInfo = extensionInfo.get(entry.getKey());
          if (extInfo != null) {
            nestedFieldType = extInfo.fqType;
          } else {
            throw new RuntimeException("Unknown name " + entry.getKey());
          }
        } else {
          nestedFieldType = getFieldType(info);
        }
        String optionInitializer = createOptionInitializer(entry.getValue(), fieldType, key,
            nestedFieldType, false, level);
        sb.append(optionInitializer).append(")");
      }
      sb.append("\n  ");
      indent(sb, level);
      sb.append(".build()");
      if (emitAsList) {
        sb.append(")");
      }
    } else if (listOrMap instanceof List) {
      sb.append("asList(\n");
      String sep = "  ";
      for (Object objectValue : (List<Object>) listOrMap) {
        sb.append(sep);
        indent(sb, level);
        if (objectValue instanceof String) {
          sb.append((String) objectValue);
        } else if (objectValue instanceof Map) {
          sb.append(createOptionInitializer(objectValue, parentType, parentField, fieldType, true,
              level));
        }
        sep = ",\n  ";
      }
      sb.append(")");
    } else {
      sb.append((String) listOrMap);
    }
    return sb.toString();
  }

  private String getFieldType(FieldInfo info) {
    return info == null ? null : info.name;
  }

  private boolean isRepeated(FieldInfo fieldInfo) {
    return fieldInfo != null && fieldInfo.label == MessageType.Label.REPEATED;
  }

  private boolean isMetadata(String key) {
    return key.charAt(0) == '@';
  }

  private void indent(StringBuilder sb, int level) {
    for (int i = 0; i < level; i++) {
      sb.append(LINE_WRAP_INDENT);
    }
  }

  // Example:
  //
  // public static final Integer DEFAULT_OPT_INT32 = 123;
  //
  private void emitMessageDefaults(MessageType messageType) throws IOException {
    List<Field> defaultFields = new ArrayList<Field>();
    for (Field field : messageType.getFields()) {
      // Message types cannot have defaults
      if (!isMessageType(messageType, field) || isRepeated(field)) {
        defaultFields.add(field);
      }
    }

    if (!defaultFields.isEmpty()) {
      writer.emitEmptyLine();
    }

    for (Field field : defaultFields) {
      String javaName = getJavaFieldType(messageType, field);
      if (javaName == null) {
        throw new IllegalArgumentException(
            "Unknown type for field " + field + " in message " + messageType.getName());
      }
      String defaultValue = getDefaultValue(messageType, field);

      writer.emitField(javaName, "DEFAULT_" + field.getName().toUpperCase(Locale.US),
          EnumSet.of(PUBLIC, STATIC, FINAL), defaultValue);
    }
  }

  private String getJavaFieldType(MessageType messageType, Field field) {
    return getJavaFieldType(protoFile, messageType, field);
  }

  private String sanitize(String name) {
    return JAVA_KEYWORDS.contains(name) ? "_" + name : name;
  }

  private String getDefaultValue(MessageType messageType, Field field) {
    String initialValue = field.getDefault();
    if (isRepeated(field)) return "Collections.emptyList()";
    String javaName = javaName(messageType, field.getType());
    if (isScalar(field.getType())) {
      return getInitializerForType(initialValue, javaName);
    } else {
      if (initialValue != null) {
        return javaName + "." + initialValue;
      } else {
        String fullyQualifiedName = fullyQualifiedName(messageType, field.getType());
        if (isEnum(fullyQualifiedName)) {
          return javaName + "." + enumDefaults.get(fullyQualifiedName);
        } else {
          throw new IllegalArgumentException(
              "Field " + field + " cannot have default value");
        }
      }
    }
  }

  private String getInitializerForType(String initialValue, String javaTypeName) {
    if ("Boolean".equals(javaTypeName)) {
      return initialValue == null ? "false" : initialValue;
    } else if ("Integer".equals(javaTypeName)) {
      // Wrap unsigned values
      return initialValue == null ? "0" : toInt(initialValue);
    } else if ("Long".equals(javaTypeName)) {
      // Wrap unsigned values and add an 'L'
      return initialValue == null ? "0L" : toLong(initialValue) + "L";
    } else if ("Float".equals(javaTypeName)) {
      return initialValue == null ? "0F" : initialValue + "F";
    } else if ("Double".equals(javaTypeName)) {
      return initialValue == null ? "0D" : initialValue + "D";
    } else if ("String".equals(javaTypeName)) {
      return quoteString(initialValue);
    } else if ("ByteString".equals(javaTypeName)) {
      if (initialValue == null) {
        return "ByteString.EMPTY";
      } else {
        return "ByteString.of(\"" + Stringer.encode(initialValue.getBytes(ISO_8859_1)) + "\")";
      }
    } else {
      throw new IllegalArgumentException(javaTypeName + " is not an allowed scalar type");
    }
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue());
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  // Example:
  //
  // /**
  //  * An optional int32
  //  */
  // @ProtoField(
  //   tag = 1,
  //   type = INT32
  // )
  // public final Integer optional_int32;
  //
  private void emitMessageFields(MessageType messageType) throws IOException {
    Set<Integer> tags = new HashSet<Integer>();

    for (Field field : messageType.getFields()) {
      // Check for duplicate tags
      int tag = field.getTag();
      if (tags.contains(tag)) {
        throw new RuntimeException("Duplicate tag value for field "
            + messageType.getFullyQualifiedName() + "." + field.getName());
      }
      tags.add(tag);

      String fieldType = field.getType();
      String javaName = javaName(messageType, fieldType);
      Map<String, String> map = new LinkedHashMap<String, String>();
      map.put("tag", String.valueOf(tag));

      boolean isEnum = false;
      if (isScalar(fieldType)) {
        map.put("type", scalarTypeConstant(fieldType));
      } else {
        String fullyQualifiedName = fullyQualifiedName(messageType, fieldType);
        isEnum = isEnum(fullyQualifiedName);
        if (isEnum) map.put("type", "ENUM");
      }

      if (!isOptional(field)) {
        if (isPacked(field, isEnum)) {
          map.put("label", "PACKED");
        } else {
          map.put("label", field.getLabel().toString());
        }
      }

      writer.emitEmptyLine();
      emitDocumentation(field.getDocumentation());
      writer.emitAnnotation(ProtoField.class, map);

      if (isRepeated(field)) javaName = "List<" + javaName + ">";
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC, FINAL));
    }
  }

  // Example:
  //
  // private SimpleMessage(Builder builder) {
  //   super(builder);
  //   this.optional_int32 = builder.optional_int32;
  // }
  //
  private void emitMessageConstructor(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, messageType.getName(), EnumSet.of(PRIVATE), "Builder", "builder");
    writer.emitStatement("super(builder)");
    for (Field field : messageType.getFields()) {
      if (isRepeated(field)) {
        writer.emitStatement("this.%1$s = immutableCopyOf(builder.%1$s)",
            sanitize(field.getName()));
      } else {
        writer.emitStatement("this.%1$s = builder.%1$s", sanitize(field.getName()));
      }
    }
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public boolean equals(Object other) {
  //   if (other == this) return true;
  //   if (!(other instanceof SimpleMessage)) return false;
  //   SimpleMessage o = (SimpleMessage) other;
  //   if (!Wire.equals(optional_int32, o.optional_int32)) return false;
  //   return true;
  //
  private void emitMessageEquals(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("boolean", "equals", EnumSet.of(PUBLIC), "Object", "other");

    List<Field> fields = messageType.getFields();
    if (fields.isEmpty()) {
      writer.emitStatement("return other instanceof %s", messageType.getName());
    } else {
      writer.emitStatement("if (other == this) return true");
      writer.emitStatement("if (!(other instanceof %s)) return false", messageType.getName());
      if (hasOnlyOneField(messageType)) {
        String name = sanitize(fields.get(0).getName());
        // If the field is named "other" or "o", qualify the field reference with 'this'
        writer.emitStatement("return equals(%1$s, ((%2$s) other).%3$s)",
            addThisIfOneOf(name, "other", "o"), messageType.getName(), name);
      } else {
        writer.emitStatement("%1$s o = (%1$s) other", messageType.getName());
        if (hasExtensions(messageType)) {
          writer.emitStatement("if (!extensionsEqual(o)) return false");
        }
        StringBuilder sb = new StringBuilder();
        String prefix = "return ";
        for (Field field : fields) {
          sb.append(prefix);
          prefix = "\n&& ";
          // If the field is named "other" or "o", qualify the field reference with 'this'
          String name = sanitize(field.getName());
          sb.append(String.format("equals(%1$s, o.%2$s)",
              addThisIfOneOf(name, "other", "o"), name));
        }
        writer.emitStatement(sb.toString());
      }
    }
    writer.endMethod();
  }

  private String addThisIfOneOf(String name, String... matches) {
    for (String match : matches) {
      if (match.equals(name)) {
        return "this." + name;
      }
    }
    return name;
  }

  private boolean hasOnlyOneField(MessageType messageType) {
    return messageType.getFields().size() == 1 && !hasExtensions(messageType);
  }

  // Example:
  //
  // @Override
  // public int hashCode() {
  //   if (hashCode == 0) {
  //     int result = super.extensionsHashCode();
  //     result = result * 37 + (f != null ? f.hashCode() : 0);
  //     hashCode = result;
  //   }
  //   return hashCode;
  // }
  //
  private void emitMessageHashCode(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("int", "hashCode", EnumSet.of(PUBLIC));

    if (!hasFields(messageType) && !hasExtensions(messageType)) {
      writer.emitStatement("return 0");
    } else if (hasOnlyOneField(messageType)) {
      Field field = messageType.getFields().get(0);
      String name = sanitize(field.getName());
      // If the field is named "result", qualify the field reference with 'this'
      name = addThisIfOneOf(name, "result");
      writer.emitStatement("int result = hashCode");
      writer.emitStatement(
          "return result != 0 ? result : (hashCode = %1$s != null ? %1$s.hashCode() : 0)", name);
    } else {
      writer.emitStatement("int result = hashCode");
      writer.beginControlFlow("if (result == 0)");
      boolean afterFirstAssignment = false;
      if (hasExtensions(messageType)) {
        writer.emitStatement("result = extensionsHashCode()");
        afterFirstAssignment = true;
      }
      for (Field field : messageType.getFields()) {
        String name = sanitize(field.getName());
        // If the field is named "result", qualify the field reference with 'this'
        name = addThisIfOneOf(name, "result");
        if (afterFirstAssignment) {
          writer.emitStatement("result = result * 37 + (%1$s != null ? %1$s.hashCode() : 0)", name);
        } else {
          writer.emitStatement("result = %1$s != null ? %1$s.hashCode() : 0", name);
          afterFirstAssignment = true;
        }
      }
      writer.emitStatement("hashCode = result");
      writer.endControlFlow();
      writer.emitStatement("return result");
    }
    writer.endMethod();
  }

  private void emitBuilder(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginType("Builder", "class", EnumSet.of(PUBLIC, STATIC, FINAL),
        (hasExtensions(messageType) ? "ExtendableBuilder<" : "Message.Builder<")
            + messageType.getName()
            + ">");
    emitBuilderFields(messageType);
    emitBuilderConstructors(messageType);
    emitBuilderSetters(messageType);
    if (hasExtensions(messageType)) emitBuilderSetExtension(messageType);
    emitBuilderBuild(messageType);
    writer.endType();
  }

  private void emitBuilderFields(MessageType messageType) throws IOException {
    List<Field> fields = messageType.getFields();

    if (!fields.isEmpty()) writer.emitEmptyLine();
    for (Field field : fields) {
      String javaName = getJavaFieldType(messageType, field);
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC));
    }
  }

  // Example:
  //
  // public Builder() {
  // }
  //
  // public Builder(SimpleMessage message) {
  //   super(message);
  //   if (message == null) return;
  //   this.optional_int32 = message.optional_int32;
  //   ...
  // }
  //
  private void emitBuilderConstructors(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC));
    writer.endMethod();

    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC), messageType.getName(), "message");
    writer.emitStatement("super(message)");
    List<Field> fields = messageType.getFields();
    if (!fields.isEmpty()) writer.emitStatement("if (message == null) return");
    for (Field field : fields) {
      if (isRepeated(field)) {
        writer.emitStatement("this.%1$s = copyOf(message.%1$s)", sanitize(field.getName()));
      } else {
        writer.emitStatement("this.%1$s = message.%1$s", sanitize(field.getName()));
      }
    }
    writer.endMethod();
  }

  private void emitBuilderSetters(MessageType messageType) throws IOException {
    for (Field field : messageType.getFields()) {
      String javaName = getJavaFieldType(messageType, field);
      List<String> args = new ArrayList<String>();
      args.add(javaName);
      String sanitized = sanitize(field.getName());
      args.add(sanitized);

      writer.emitEmptyLine();

      emitDocumentation(field.getDocumentation());
      writer.beginMethod("Builder", sanitized, EnumSet.of(PUBLIC), args, null);
      writer.emitStatement("this.%1$s = %1$s", sanitized);
      writer.emitStatement("return this");
      writer.endMethod();
    }
  }

  // Example:
  //
  // @Override
  // public <E> Builder setExtension(Extension<ExternalMessage, E> extension, E value) {
  //   super.setExtension(extension, value);
  //   return this;
  // }
  //
  private void emitBuilderSetExtension(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("<E> Builder", "setExtension", EnumSet.of(PUBLIC),
        "Extension<" + messageType.getName() + ", E>", "extension", "E", "value");
    writer.emitStatement("super.setExtension(extension, value)");
    writer.emitStatement("return this");
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public SimpleMessage build() {
  //   checkRequiredFields();
  //   return new SimpleMessage(this);
  // }
  //
  // The call to checkRequiredFields will be emitted only if the message has
  // required fields.
  //
  private void emitBuilderBuild(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod(messageType.getName(), "build", EnumSet.of(PUBLIC));
    if (hasRequiredFields(messageType)) {
      writer.emitStatement("checkRequiredFields()");
    }
    writer.emitStatement("return new %s(this)", messageType.getName());
    writer.endMethod();
  }

  private boolean hasEnum(List<Type> types) {
    for (Type type : types) {
      if (type instanceof EnumType || hasEnum(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasExtensions(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType && hasExtensions(((MessageType) type))) return true;
      if (hasExtensions(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasMessage(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType && !hasExtensions(((MessageType) type))) return true;
      if (hasMessage(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasRepeatedField(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType) {
        for (Field field : ((MessageType) type).getFields()) {
          if (isRepeated(field)) return true;
        }
      }
      if (hasRepeatedField(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasBytesField(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType) {
        for (Field field : ((MessageType) type).getFields()) {
          if ("bytes".equals(field.getType())) return true;
        }
      }
      if (hasBytesField(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasFields(Type type) {
    return type instanceof MessageType && !((MessageType) type).getFields().isEmpty();
  }

  private boolean hasRequiredFields(Type type) {
    if (type instanceof MessageType) {
      for (MessageType.Field field : ((MessageType) type).getFields()) {
        if (isRequired(field)) return true;
      }
    }
    return false;
  }

  private void getDatatypesAndLabels(Type type, Collection<Datatype> types,
      Collection<Label> labels) {
    if (type instanceof MessageType) {
      for (MessageType.Field field : ((MessageType) type).getFields()) {
        String fieldType = field.getType();
        Datatype datatype = Datatype.of(fieldType);
        // If not scalar, determine whether it is an enum
        if (datatype == null && isEnum(fullyQualifiedName((MessageType) type, field.getType()))) {
          datatype = Datatype.ENUM;
        }
        if (datatype != null) types.add(datatype);

        // Convert Protoparser label to Wire label
        MessageType.Label label = field.getLabel();
        switch (label) {
          case OPTIONAL:
            labels.add(Label.OPTIONAL);
            break;
          case REQUIRED:
            labels.add(Label.REQUIRED);
            break;
          case REPEATED:
            if (isPacked(field, false)) {
              labels.add(Label.PACKED);
            } else {
              labels.add(Label.REPEATED);
            }
            break;
          default:
            throw new AssertionError("Unknown label " + label);
        }
      }

      for (Type nestedType : type.getNestedTypes()) {
        getDatatypesAndLabels(nestedType, types, labels);
      }
    }
  }

  private boolean hasDocumentation(String documentation) {
    return documentation != null && !documentation.isEmpty();
  }

  /**
   * Returns the name of the {@code Message} type constant (e.g.,
   * {@code INT32} or {@code STRING}) associated
   * with the given scalar type (e.g., {@code int32} or {@code string}).
   */
  private String scalarTypeConstant(String type) {
    return type.toUpperCase(Locale.US);
  }

  /**
   * Returns true if the given type name is one of the standard .proto
   * scalar types, e.g., {@code int32}, {@code string}, etc.
   */
  private boolean isScalar(String type) {
    return JAVA_TYPES.containsKey(type);
  }

  /**
   * Returns the Java type associated with a standard .proto
   * scalar type, e.g., {@code int32}, {@code string}, etc.,
   * or null if the name is not that of a scalar type.
   */
  private String scalarType(String type) {
    return JAVA_TYPES.get(type);
  }

  /**
   * Returns true if the given fully-qualified name (with a .proto package name)
   * refers to an .proto enumerated type.
   */
  private boolean isEnum(String type) {
    return enumTypes.contains(type);
  }

  private boolean isOptional(Field field) {
    return field.getLabel() == MessageType.Label.OPTIONAL;
  }

  private boolean isRepeated(Field field) {
    return field.getLabel() == MessageType.Label.REPEATED;
  }

  private boolean isRequired(Field field) {
    return field.getLabel() == MessageType.Label.REQUIRED;
  }

  private boolean isMessageType(MessageType messageType, Field field) {
    return !isScalar(field.getType())
        && !isEnum(fullyQualifiedName(messageType, field.getType()));
  }

  private boolean isPacked(Field field, boolean isEnum) {
    return "true".equals(field.getExtensions().get("packed"))
        && (isEnum || isPackableScalar(field));
  }

  private boolean isPackableScalar(Field field) {
    String type = field.getType();
    return isScalar(type) && !"string".equals(type) && !"bytes".equals(type);
  }

  private String javaName(MessageType messageType, String type) {
    String scalarType = scalarType(type);
    return scalarType != null
        ? scalarType : shortenJavaName(javaName(fullyQualifiedName(messageType, type)));
  }

  private String javaName(String fqName) {
    return javaSymbolMap.get(fqName);
  }

  private String fullyQualifiedName(MessageType messageType, String type) {
    return fullyQualifiedName(protoFile, messageType, type);
  }

  private boolean typeIsComplete(String type) {
    return javaSymbolMap.containsKey(type);
  }

  private String fullyQualifiedJavaName(MessageType messageType, String type) {
    return isScalar(type) ? null : javaName(fullyQualifiedName(messageType, type));
  }

  private String shortenJavaName(String fullyQualifiedName) {
    return shortenJavaName(protoFile, fullyQualifiedName);
  }
}
