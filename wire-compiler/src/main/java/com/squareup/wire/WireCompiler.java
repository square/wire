/*
 * Copyright 2013 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.wire;

import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.DataType.ScalarType;
import com.squareup.protoparser.EnumElement;
import com.squareup.protoparser.ExtendElement;
import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.MessageElement;
import com.squareup.protoparser.OneOfElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.RpcElement;
import com.squareup.protoparser.ServiceElement;
import com.squareup.protoparser.TypeElement;
import com.squareup.wire.model.Linker;
import com.squareup.wire.model.Loader;
import com.squareup.wire.model.RootSet;
import com.squareup.wire.model.WireProtoFile;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import okio.ByteString;

import static com.squareup.wire.Message.Datatype;
import static com.squareup.wire.Message.Label;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

/** Compiler for Wire protocol buffers. */
public class WireCompiler {
  static final String LINE_WRAP_INDENT = "    ";

  /**
   * Field options that don't trigger generation of a FIELD_OPTIONS_* field.
   */
  static final Set<String> DEFAULT_FIELD_OPTION_KEYS =
      new LinkedHashSet<String>(Arrays.asList("default", "deprecated", "packed"));

  private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
  private static final String CODE_GENERATED_BY_WIRE =
      "Code generated by Wire protocol buffer compiler, do not edit.";

  private final String repoPath;
  private final IO io;
  private final Set<String> typesToEmit = new LinkedHashSet<String>();
  private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
  private final Set<String> javaSymbols = new LinkedHashSet<String>();
  private final Set<String> enumTypes = new LinkedHashSet<String>();
  private final Map<String, String> enumDefaults = new LinkedHashMap<String, String>();
  private final Map<String, ExtensionInfo> extensionInfo =
      new LinkedHashMap<String, ExtensionInfo>();
  private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();

  private final List<String> extensionClasses = new ArrayList<String>();
  private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);
  private final CommandLineOptions options;

  private final WireLogger log;

  private ProtoFile protoFile;
  private String sourceFileName;
  private String protoFileName;
  private String typeBeingGenerated = "";

  private Constructor<?> serviceWriterConstructor;

  /**
   * Runs the compiler.  See {@link CommandLineOptions} for command line options.
   */
  public static void main(String... args) {
    try {
      new WireCompiler(new CommandLineOptions(args)).compile();
    } catch (WireException e) {
      System.err.print("Fatal: ");
      e.printStackTrace(System.err);
      System.exit(1);
    }
  }

  private static Constructor<?> loadServiceWriter(String serviceWriterClassName)
      throws WireException {
    Class<?> serviceWriterClass;
    try {
      serviceWriterClass = Class.forName(serviceWriterClassName);
    } catch (ClassNotFoundException e) {
      throw new WireException("Unable to load ServiceWriter class "
          + serviceWriterClassName + ".", e);
    }

    if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
      throw new WireException(
          "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
    }

    try {
      return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
    } catch (NoSuchMethodException e) {
      throw new WireException("ServiceWriter class "
          + serviceWriterClassName
          + " needs a constructor 'public "
          + serviceWriterClassName
          + "(JavaWriter writer, List<String> options)'.", e);
    }
  }

  @Deprecated
  public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions)
      throws WireException {
    this(new CommandLineOptions(protoPath, outputDirectory, sourceFileNames, roots, registryClass,
        emitOptions, new LinkedHashSet<String>(enumOptions),
        serviceWriterConstructor == null ? null : serviceWriterConstructor.getName(),
        serviceWriterOptions, false, false));
  }

  WireCompiler(CommandLineOptions options) throws WireException {
    this(options, new IO.FileIO(), new ConsoleWireLogger(options.quiet));
  }

  WireCompiler(CommandLineOptions options, IO io, WireLogger logger) throws WireException {
    this.options = options;
    this.io = io;
    this.log = logger;

    String protoPath = options.protoPath;
    if (options.javaOut == null) {
      throw new WireException("Must specify " + CommandLineOptions.JAVA_OUT_FLAG + " flag");
    }
    if (options.protoPath == null) {
      protoPath = System.getProperty("user.dir");
      System.err.println(
          CommandLineOptions.PROTO_PATH_FLAG + " flag not specified, using current dir "
              + protoPath);
    }
    if (options.serviceWriter != null) {
      serviceWriterConstructor =
          WireCompiler.loadServiceWriter(options.serviceWriter);
    }
    this.repoPath = protoPath;
    this.typesToEmit.addAll(options.roots);
  }

  public void compile() throws WireException {
    Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();


    Loader loader = new Loader(repoPath, io);

    for (String sourceFilename : options.sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      try {
        ProtoFile protoFile = io.parse(sourcePath);
        loader.add(sourceFilename);
        parsedFiles.put(sourcePath, protoFile);
        loadSymbols(protoFile);
      } catch (IOException e) {
        throw new WireException("Error loading symbols for " + sourcePath, e);
      }
    }

    List<WireProtoFile> wireProtoFiles = loader.loaded();
    Linker linker = new Linker();
    RootSet rootSet = linker.link(wireProtoFiles);

    if (!typesToEmit.isEmpty()) {
      log.info("Analyzing dependencies of root types.");
      rootSet = rootSet.retainRoots(typesToEmit);
      findDependencies(parsedFiles.values());
    }

    for (Map.Entry<String, ProtoFile> entry : parsedFiles.entrySet()) {
      this.sourceFileName = entry.getKey();
      this.protoFile = entry.getValue();
      this.protoFileName = protoFileName(protoFile.filePath());
      log.info("Compiling proto source file " + sourceFileName);
      try {
        compileOne();
      } catch (IOException e) {
        throw new WireException("Error compiling " + entry.getKey(), e);
      }
    }

    if (options.registryClass != null) {
      int packageClassSep = options.registryClass.lastIndexOf(".");
      String javaPackage = options.registryClass.substring(0, packageClassSep);
      String className = options.registryClass.substring(packageClassSep + 1);
      OutputArtifact artifact = new OutputArtifact(options.javaOut, javaPackage, className);
      log.artifact(artifact);
      if (!options.dryRun) {
        try {
          emitRegistry(artifact);
        } catch (IOException e) {
          throw new WireException("Error emitting registry class " + options.registryClass, e);
        }
      }
    }
  }

  boolean shouldEmitOptions() {
    return options.emitOptions;
  }

  Set<String> enumOptions() {
    return options.enumOptions;
  }

  ProtoFile getProtoFile() {
    return protoFile;
  }

  OptionsMapMaker getOptionsMapMaker() {
    return optionsMapMaker;
  }

  String getEnumDefault(String fullyQualifiedName) {
    return enumDefaults.get(fullyQualifiedName);
  }

  FieldInfo getField(String dollarName) {
    return fieldMap.get(dollarName);
  }

  String javaName(ProtoFile protoFile, MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(protoFile, javaName(fullyQualifiedName(protoFile, messageType, type)));
  }

  boolean fullyQualifiedNameIsOutsidePackage(String fqName) {
    return fqName != null && !getJavaPackage().equals(getPackageFromFullyQualifiedJavaName(fqName));
  }

  String prefixWithPackageName(String name) {
    return prefixWithPackageName(protoFile, name);
  }

  boolean hasFields(TypeElement type) {
    return type instanceof MessageElement && !allFields((MessageElement) type).isEmpty();
  }

  boolean hasExtensions(MessageElement messageType) {
    return !messageType.extensions().isEmpty();
  }

  String getTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(index + 1);
  }

  ExtensionInfo getExtension(String name) {
    return extensionInfo.get(name);
  }

  String getInitializerForType(Object initialValue, String javaTypeName) {
    if ("Boolean".equals(javaTypeName)) {
      return initialValue == null ? "false" : String.valueOf(initialValue);
    } else if ("Integer".equals(javaTypeName)) {
      return initialValue == null ? "0" : toInt(String.valueOf(initialValue));
    } else if ("Long".equals(javaTypeName)) {
      return initialValue == null ? "0L" : toLong(String.valueOf(initialValue));
    } else if ("Float".equals(javaTypeName)) {
      return initialValue == null ? "0F" : String.valueOf(initialValue) + "F";
    } else if ("Double".equals(javaTypeName)) {
      return initialValue == null ? "0D" : String.valueOf(initialValue) + "D";
    } else if ("String".equals(javaTypeName)) {
      return quoteString((String) initialValue);
    } else if ("ByteString".equals(javaTypeName)) {
      if (initialValue == null) {
        return "ByteString.EMPTY";
      } else {
        return "ByteString.decodeBase64(\"" + ByteString.of(
            String.valueOf(initialValue).getBytes(ISO_8859_1)).base64() + "\")";
      }
    } else {
      throw new WireCompilerException(javaTypeName + " is not an allowed scalar type");
    }
  }

  /**
   * Returns true if the given fully-qualified name (with a .proto package name)
   * refers to an .proto enumerated type.
   */
  boolean isEnum(String type) {
    return enumTypes.contains(type);
  }

  String javaName(MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(javaName(fullyQualifiedName(messageType, type)));
  }

  String javaName(String fqName) {
    return javaSymbolMap.get(fqName);
  }

  String fullyQualifiedName(TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String fullyQualifiedName(String fqName, String type) {
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String shortenJavaName(String fullyQualifiedName) {
    return shortenJavaName(protoFile, fullyQualifiedName);
  }

  boolean isRedacted(OptionElement option) {
    return option.name().endsWith(".redacted") && "true".equals(String.valueOf(option.value()));
  }

  private void compileOne() throws IOException {
    typeBeingGenerated = "";

    if (hasExtends()) {
      OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
          "Ext_" + protoFileName);
      log.artifact(artifact);

      if (!options.dryRun) {
        emitExtensionClass(artifact);
        extensionClasses.add(artifact.fullClassName());
      }
    }

    for (TypeElement type : protoFile.typeElements()) {
      if (shouldEmitType(type.qualifiedName())) {
        String savedType = typeBeingGenerated;
        typeBeingGenerated += type.name() + ".";
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            type.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitMessageClass(type, artifact);
        }
        typeBeingGenerated = savedType;
      }
    }

    for (ServiceElement service : protoFile.services()) {
      if (shouldEmitService(service.qualifiedName())) {
        ServiceElement.Builder serviceBuilder = ServiceElement.builder()
            .name(service.name())
            .qualifiedName(service.qualifiedName())
            .documentation(service.documentation())
            .addOptions(service.options());
        for (RpcElement method : service.rpcs()) {
          if (shouldEmitServiceMethod(service.qualifiedName(), method.name())) {
            serviceBuilder.addRpc(method);
          }
        }

        ServiceElement limitedService = serviceBuilder.build();
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            service.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitServiceInterface(limitedService, artifact);
        }
      }
    }
  }

  private boolean hasFieldOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          for (OptionElement option : field.options()) {
            if (!WireCompiler.DEFAULT_FIELD_OPTION_KEYS.contains(option.name())) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  private boolean hasMessageOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private boolean hasEnumOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private void getTypes(TypeElement parent, List<TypeElement> types) {
    types.add(parent);
    for (TypeElement nestedType : parent.nestedElements()) {
      getTypes(nestedType, types);
    }
  }

  private void emitRegistry(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitPackage(artifact.javaPackage());

      writer.emitImports("java.util.List");
      writer.emitEmptyLine();

      int extensionsCount = extensionClasses.size();
      if (extensionsCount == 0) {
        writer.emitStaticImports("java.util.Collections.emptyList");
      } else {
        writer.emitStaticImports("java.util.Arrays.asList",
            "java.util.Collections.unmodifiableList");
      }
      writer.emitEmptyLine();
      writer.beginType(artifact.className(), "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      String classes;
      if (extensionsCount == 0) {
        classes = "emptyList()";
      } else {
        StringBuilder sb = new StringBuilder("unmodifiableList(asList(\n");
        for (int i = 0; i < extensionsCount; i++) {
          sb.append(writer.compressType(extensionClasses.get(i)));
          sb.append(".class");
          if (i < extensionsCount - 1) {
            sb.append(",\n");
          }
        }
        sb.append("))");
        classes = sb.toString();
      }

      writer.emitAnnotation("SuppressWarnings(\"unchecked\")");

      String wildcard = extensionsCount == 1 ? extensionClasses.get(0) : "?";
      String listType = "List<Class<" + wildcard + ">>";
      writer.emitField(listType, "EXTENSIONS", EnumSet.of(PUBLIC, STATIC, FINAL), classes);
      writer.emitEmptyLine();

      // Private no-args constructor
      writer.beginMethod(null, artifact.className(), EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private boolean shouldEmitType(String name) {
    return typesToEmit.isEmpty() || typesToEmit.contains(name);
  }

  private boolean shouldEmitService(String serviceName) {
    if (typesToEmit.isEmpty()) {
      return true;
    }
    for (String type : typesToEmit) {
      if (type.equals(serviceName) || type.startsWith(serviceName + "#")) {
        return true;
      }
    }
    return false;
  }

  private boolean shouldEmitServiceMethod(String serviceName, String method) {
    if (method == null) {
      throw new IllegalArgumentException("No method specified");
    }
    return typesToEmit.isEmpty() //
        || typesToEmit.contains(serviceName) //
        || typesToEmit.contains(serviceName + "#" + method);
  }

  private void findDependencies(Collection<ProtoFile> protoFiles) throws WireException {
    Set<String> loadedDependencies = new LinkedHashSet<String>();
    int count = typesToEmit.size();
    while (true) {
      for (ProtoFile protoFile : protoFiles) {
        findDependenciesHelper(protoFile, loadedDependencies);
      }
      int newCount = typesToEmit.size();
      if (newCount == count) {
        break;
      }
      count = newCount;
    }
  }

  private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
      throws WireException {
    // Load symbols from imports
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        try {
          ProtoFile dependencyFile = io.parse(dep);
          loadSymbols(dependencyFile);
        } catch (IOException e) {
          throw new WireException("Error loading symbols for " + dep, e);
        }
        loadedDependencies.add(dependency);
      }
    }

    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String typeName = extend.qualifiedName();
      typesToEmit.add(typeName);
      for (FieldElement field : extend.fields()) {
        // FIXME: we need to determine the fully-qualified name of the extension field.
        // For now, just prepend the proto file's package name unless the type already appears
        // to be complete.
        String fieldTypeName = typeIsComplete(field.type().toString()) ? field.type().toString()
            : prefixWithPackageName(protoFile, field.type().toString());
        typesToEmit.add(fieldTypeName);
      }
    }

    addDependencies(protoFile.typeElements(), getJavaPackage(protoFile) + ".");
    addDependencies(protoFile.services());
  }

  /** Expands the set of types to emit to include the request/response types of service methods. */
  private void addDependencies(List<ServiceElement> services) {
    for (ServiceElement service : services) {
      String fqName = service.qualifiedName();
      if (shouldEmitService(fqName)) {
        for (RpcElement rpc : service.rpcs()) {
          if (shouldEmitServiceMethod(fqName, rpc.name())) {
            addDependencyBranch(fullyQualifiedName(fqName, rpc.requestType().toString()));
            addDependencyBranch(fullyQualifiedName(fqName, rpc.responseType().toString()));
          }
        }
      }
    }
  }

  /** Expands the set of types to emit to include types of fields of current emittable types. */
  private void addDependencies(List<TypeElement> types, String javaPrefix) {
    for (TypeElement type : types) {
      String name = type.name();
      String fqName = type.qualifiedName();
      if (type instanceof MessageElement && typesToEmit.contains(fqName)) {
        for (FieldElement field : allFields((MessageElement) type)) {
          String fieldType = field.type().toString();
          if (!TypeInfo.isScalar(fieldType)) {
            String fqFieldType = fullyQualifiedName(fqName, field.type().toString());
            addDependencyBranch(fqFieldType);
          }
        }
      }
      addDependencies(type.nestedElements(), javaPrefix + name + ".");
    }
  }

  /** Adds a type name and all its ancestors to the set of emittable types. */
  private void addDependencyBranch(String name) {
    while (typeIsComplete(name)) {
      typesToEmit.add(name);
      name = removeTrailingSegment(name);
    }
  }

  private String removeTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? "" : name.substring(0, index);
  }

  public String getTypeBeingGenerated() {
    // Strip trailing '.'
    return typeBeingGenerated.substring(0, typeBeingGenerated.length() - 1);
  }

  private enum LoadSymbolsPass {
    LOAD_TYPES, LOAD_FIELDS
  }

  private void loadSymbols(ProtoFile protoFile) throws IOException {
    // Make two passes through the input files. In the first pass we collect message and enum
    // types, and in the second pass we collect field types.
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_TYPES);
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_FIELDS);
  }

  // Call with pass == LOAD_TYPES, then pass == LOAD_FIELDS
  private void loadSymbolsHelper(ProtoFile protoFile, Set<String> loadedDependencies,
      LoadSymbolsPass pass) throws IOException {
    // Load symbols from imports
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        ProtoFile dependencyFile = io.parse(dep);
        loadSymbolsHelper(dependencyFile, loadedDependencies, pass);
        loadedDependencies.add(dependency);
      }
    }

    addTypes(protoFile.typeElements(), getJavaPackage(protoFile) + ".", pass);
    addExtensions(protoFile);
  }

  private void addExtensions(ProtoFile protoFile) {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(protoFile, null, fieldType);
        if (type == null) {
          type = javaName(protoFile, null, prefixWithPackageName(protoFile, fieldType));
        }
        type = shortenJavaName(protoFile, type);
        String fqName = prefixWithPackageName(protoFile, field.name());
        String fqType;

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum =
            !isScalar && isEnum(fullyQualifiedName(protoFile, (String) null, fieldType));
        if (isScalar) {
          type = field.type().toString();
          fqType = type;
        } else if (isEnum) {
          // Store fully-qualified name for enumerations so we can identify them later
          type = fullyQualifiedName(protoFile, (String) null, fieldType);
          fqType = type;
        } else {
          fqType = fullyQualifiedName(protoFile, (String) null, fieldType);
        }

        String location = protoFileName(protoFile.filePath());
        String fqLocation = getJavaPackage(protoFile) + ".Ext_" + location;
        ExtensionInfo info =
            new ExtensionInfo(type, fqType, location, fqLocation, field.label());
        extensionInfo.put(fqName, info);
      }
    }
  }

  // Ensure a non-null value for the Java package name.
  String getJavaPackage(ProtoFile protoFile) {
    OptionElement javaPackage = OptionElement.findByName(protoFile.options(), "java_package");
    if (javaPackage != null) {
      return (String) javaPackage.value();
    }
    return protoFile.packageName() == null ? "" : protoFile.packageName();
  }

  String getJavaPackage() {
    return getJavaPackage(protoFile);
  }

  private void addTypes(List<TypeElement> types, String javaPrefix, LoadSymbolsPass pass) {
    for (TypeElement type : types) {
      String name = type.name();
      if (pass == LoadSymbolsPass.LOAD_TYPES) {
        String fqName = type.qualifiedName();
        javaSymbolMap.put(fqName, javaPrefix + name);
        if (type instanceof EnumElement) {
          EnumElement enumType = (EnumElement) type;
          if (!enumTypes.contains(fqName)) {
            enumTypes.add(fqName);
            enumDefaults.put(fqName, enumType.constants().get(0).name());
          }
        }
      } else if (type instanceof MessageElement) {
        addFields((MessageElement) type);
      }
      addTypes(type.nestedElements(), javaPrefix + name + ".", pass);
    }
  }

  private void addFields(MessageElement messageType) {
    for (FieldElement field : allFields(messageType)) {
      String fieldType = field.type().toString();
      String fqMessageName = messageType.qualifiedName();
      String key = fqMessageName + "$" + field.name();
      fieldMap.put(key, new FieldInfo(
          TypeInfo.isScalar(fieldType) ? fieldType : fullyQualifiedName(fqMessageName, fieldType),
          field.label()));
    }
  }

  private String fullyQualifiedName(ProtoFile protoFile, TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  private String fullyQualifiedName(ProtoFile protoFile, String fqName, String type) {
    if (typeIsComplete(type)) {
      return type;
    } else {
      String prefix = fqName == null ? protoFile.packageName() : fqName;
      while (!prefix.isEmpty()) {
        String fqname = prefix + "." + type;
        if (typeIsComplete(fqname)) return fqname;
        prefix = removeTrailingSegment(prefix);
      }
    }
    throw new WireCompilerException(
        "Unknown type " + type + " in type " + (fqName == null ? "<unknown>" : fqName));
  }

  private String shortenJavaName(ProtoFile protoFile, String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaTypeBeingGenerated = getJavaPackage(protoFile) + "." + typeBeingGenerated;
    if (fullyQualifiedName.startsWith(javaTypeBeingGenerated)) {
      return fullyQualifiedName.substring(javaTypeBeingGenerated.length());
    }

    // Dependencies in javaSymbolMap are already imported.
    for (String javaSymbol : javaSymbolMap.values()) {
      if (fullyQualifiedName.startsWith(javaSymbol)) {
        // omit package part
        String pkgPrefix = getPackageFromFullyQualifiedJavaName(fullyQualifiedName) + '.';
        return fullyQualifiedName.substring(pkgPrefix.length());
      }
    }

    return fullyQualifiedName;
  }

  private String protoFileName(String path) {
    int slashIndex = path.lastIndexOf('/');
    if (slashIndex != -1) {
      path = path.substring(slashIndex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  private void emitMessageClass(TypeElement type, OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName.replace("\\", "\\\\"));
      writer.emitPackage(getJavaPackage());

      List<TypeElement> types = new ArrayList<TypeElement>();
      getTypes(type, types);
      boolean hasMessage = hasMessage(types);
      boolean hasExtensions = hasExtensions(Collections.singletonList(type));

      Set<String> imports = new LinkedHashSet<String>();
      if (hasMessage) {
        imports.add("com.squareup.wire.Message");
      }
      if (hasMessage || hasExtensions) {
        if (hasFields(type)) {
          imports.add("com.squareup.wire.ProtoField");
        }
      }
      if (hasBytesField(types)) {
        imports.add("okio.ByteString");
      }
      if (hasEnum(types)) {
        imports.add("com.squareup.wire.ProtoEnum");
      }
      if (hasRepeatedField(types)) {
        imports.add("java.util.Collections");
        imports.add("java.util.List");
      }
      if (hasExtensions) {
        imports.add("com.squareup.wire.ExtendableMessage");
        imports.add("com.squareup.wire.Extension");
      }
      if (options.emitOptions) {
        if (hasFieldOption(types)) {
          imports.add("com.google.protobuf.FieldOptions");
        }
        if (hasMessageOption(types)) {
          imports.add("com.google.protobuf.MessageOptions");
        }
        if (hasEnumOption(types)) {
          imports.add("com.google.protobuf.EnumOptions");
        }
      }

      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(type, externalTypes);

      Map<String, ?> optionsMap = null;
      if (options.emitOptions) {
        if (type instanceof MessageElement) {
          optionsMap = optionsMapMaker.createMessageOptionsMap((MessageElement) type);
          optionsMapMaker.getOptionTypes(optionsMap, externalTypes);

          for (FieldElement field : allFields((MessageElement) type)) {
            Map<String, ?> fieldOptionsMap =
                optionsMapMaker.createFieldOptionsMap((MessageElement) type, field.options());
            optionsMapMaker.getOptionTypes(fieldOptionsMap, externalTypes);
          }
        }
      }
      imports.addAll(externalTypes);

      // Emit static imports for Datatype. and Label. enums
      Collection<Datatype> datatypes = new TreeSet<Datatype>(Datatype.ORDER_BY_NAME);
      Collection<Label> labels = new TreeSet<Label>(Label.ORDER_BY_NAME);
      getDatatypesAndLabels(type, datatypes, labels);
      // No need to emit 'label = OPTIONAL' since it is the default
      labels.remove(Label.OPTIONAL);

      MessageWriter messageWriter = new MessageWriter(this);
      messageWriter.emitHeader(writer, imports, datatypes, labels);
      messageWriter.emitType(writer, type, protoFile.packageName() + ".", optionsMap, true);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitServiceInterface(ServiceElement service, OutputArtifact artifact)
      throws IOException {
    if (serviceWriterConstructor == null) return;
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      ServiceWriter serviceWriter;
      try {
        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
            new ArrayList<String>(options.serviceWriterOptions));
      } catch (Exception e) {
        throw new IllegalStateException(
            "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
                .getName() + ": " + e);
      }

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(artifact.javaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(service, externalTypes);
      imports.addAll(externalTypes);

      serviceWriter.emitService(service, imports);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void getExternalTypes(TypeElement parent, List<String> types) {
    if (parent instanceof MessageElement) {
      MessageElement messageType = (MessageElement) parent;
      for (FieldElement field : allFields(messageType)) {
        String fqName = fullyQualifiedJavaName(messageType, field.type().toString());
        if (fqName == null) {
          continue;
        }
        if (fullyQualifiedNameIsOutsidePackage(fqName)) {
          fqName = getTopLevelMessageName(fqName);
          types.add(fqName);
        }
        String parentType = removeTrailingSegment(fqName);
        if (javaTypeIsComplete(parentType) && fullyQualifiedNameIsOutsidePackage(parentType)) {
          types.add(parentType);
        }
      }
    }
    for (TypeElement nestedType : parent.nestedElements()) {
      getExternalTypes(nestedType, types);
    }
  }

  // Convert 'Bar.Baz.Moo' to 'Bar' for use in imports.
  private String getTopLevelMessageName(String fqName) {
    // Navigate up the class hierarchy to find the outermost parent that is 'complete'.
    String parentType = removeTrailingSegment(fqName);
    while (!parentType.isEmpty()
        && javaTypeIsComplete(parentType)
        && fullyQualifiedNameIsOutsidePackage(parentType)) {
      fqName = parentType;
      parentType = removeTrailingSegment(parentType);
    }
    return fqName;
  }

  private void getExternalTypes(ServiceElement service, List<String> types) {
    for (RpcElement rpc : service.rpcs()) {
      addType(service, rpc.requestType().toString(), types);
      addType(service, rpc.responseType().toString(), types);
    }
  }

  private void addType(ServiceElement service, String method, List<String> types) {
    String serviceFQName = service.qualifiedName();
    String servicePackage =
        serviceFQName.substring(0, serviceFQName.length() - service.name().length() - 1);
    String fqName = javaName(fullyQualifiedName(servicePackage, method));
    if (fullyQualifiedNameIsOutsidePackage(fqName)) {
      types.add(fqName);
    }
  }

  private String getPackageFromFullyQualifiedJavaName(String fqName) {
    while (javaSymbolMap.containsValue(fqName)) {
      fqName = removeTrailingSegment(fqName);
    }
    return fqName;
  }

  private List<String> getExtensionTypes() {
    List<String> extensionClasses = new ArrayList<String>();
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fqName = fullyQualifiedJavaName(null, extend.qualifiedName());
      if (fullyQualifiedNameIsOutsidePackage(fqName)) {
        extensionClasses.add(fqName);
      }
      for (FieldElement field : extend.fields()) {
        String fqFieldType = fullyQualifiedJavaName(null, field.type().toString());
        if (fullyQualifiedNameIsOutsidePackage(fqFieldType)) {
          extensionClasses.add(fqFieldType);
        }
      }
    }
    return extensionClasses;
  }

  private boolean hasExtends() {
    List<ExtendElement> declarations = protoFile.extendDeclarations();
    if (!shouldEmitOptions()) {
      for (ExtendElement declaration : declarations) {
        String name = declaration.qualifiedName();
        if (!isFieldOptions(name) && !isMessageOptions(name)) {
          return true;
        }
      }
    }
    return !declarations.isEmpty();
  }

  private void emitExtensionClass(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(getJavaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      if (hasByteStringExtension()) {
        imports.add("okio.ByteString");
      }
      imports.add("com.squareup.wire.Extension");
      if (hasRepeatedExtension()) {
        imports.add("java.util.List");
      }
      List<String> extensionTypes = getExtensionTypes();

      if (shouldEmitOptions()) {
        imports.addAll(extensionTypes);
      } else {
        for (String extensionType : extensionTypes) {
          if (!isOptionType(extensionType)) {
            imports.add(extensionType);
          }
        }
      }
      writer.emitImports(imports);
      writer.emitEmptyLine();

      String className = "Ext_" + protoFileName;
      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      // Private no-args constructor
      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.emitEmptyLine();

      emitExtensions(writer);
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitExtensions(JavaWriter writer) throws IOException {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fullyQualifiedName = extend.qualifiedName();
      if (!shouldEmitOptions() && isOptionType(fullyQualifiedName)) {
        continue;
      }
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(null, fieldType);
        if (type == null) {
          type = javaName(null, prefixWithPackageName(fieldType));
        }
        type = shortenJavaName(type);
        String initialValue;
        String className = writer.compressType(name);
        String extensionName = field.name();
        String fqName = prefixWithPackageName(field.name());
        int tag = field.tag();

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fullyQualifiedName((String) null, fieldType));
        String labelString = getLabelString(field, isEnum);
        if (isScalar) {
          initialValue = String.format("Extension%n"
              + ".%1$sExtending(%2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", field.type(), className, fqName, tag, labelString);
        } else if (isEnum) {
          initialValue = String.format("Extension%n"
              + ".enumExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        } else {
          initialValue = String.format("Extension%n"
              + ".messageExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        }

        if (FieldInfo.isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", extensionName,
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  /** Works for messages or Java classes. */
  private static boolean isOptionType(String fullyQualifiedName) {
    return (isMessageOptions(fullyQualifiedName) || isFieldOptions(fullyQualifiedName));
  }

  /** Works for messages or Java classes. */
  private static boolean isFieldOptions(String name) {
    return "google.protobuf.FieldOptions".equals(name) || "com.google.protobuf.FieldOptions".equals(
        name);
  }

  /** Works for messages or Java classes. */
  private static boolean isMessageOptions(String fullyQualifiedName) {
    return "google.protobuf.MessageOptions".equals(fullyQualifiedName)
        || "com.google.protobuf.MessageOptions".equals(fullyQualifiedName);
  }

  private String prefixWithPackageName(ProtoFile protoFile, String name) {
    return protoFile.packageName() + "." + name;
  }

  private String getLabelString(FieldElement field, boolean isEnum) {
    switch (field.label()) {
      case OPTIONAL:
        return "Optional";
      case REQUIRED:
        return "Required";
      case REPEATED:
        return FieldInfo.isPacked(field, isEnum) ? "Packed" : "Repeated";
      default:
        throw new WireCompilerException("Unknown extension label \"" + field.label() + "\"");
    }
  }

  private boolean hasByteStringExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.type() == ScalarType.BYTES) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasRepeatedExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.label() == FieldElement.Label.REPEATED) {
          return true;
        }
      }
    }
    return false;
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue()) + "L";
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  private boolean hasEnum(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement || hasEnum(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasOneOf(List<TypeElement> types) {
    for (TypeElement type : types) {
      if ((type instanceof MessageElement && !((MessageElement) type).oneOfs().isEmpty())
          || hasOneOf(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasExtensions(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && hasExtensions(((MessageElement) type))) return true;
      if (hasExtensions(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasMessage(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !hasExtensions(((MessageElement) type))) return true;
      if (hasMessage(type.nestedElements())) return true;
    }
    return false;
  }

  /** Returns a list of field, including fields inside 'oneof' declarations. */
  static List<FieldElement> allFields(MessageElement messageType) {
    List<FieldElement> allFields = new ArrayList<FieldElement>();
    allFields.addAll(messageType.fields());
    for (OneOfElement oneOfElement : messageType.oneOfs()) {
      allFields.addAll(oneOfElement.fields());
    }
    return allFields;
  }

  private boolean hasRepeatedField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (FieldInfo.isRepeated(field)) return true;
        }
      }
      if (hasRepeatedField(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasBytesField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (field.type() == ScalarType.BYTES) return true;
        }
      }
      if (hasBytesField(type.nestedElements())) return true;
    }
    return false;
  }

  private void getDatatypesAndLabels(TypeElement type, Collection<Datatype> types,
      Collection<Label> labels) {
    if (type instanceof MessageElement) {
      for (FieldElement field : allFields((MessageElement) type)) {
        String fieldType = field.type().toString();
        Datatype datatype = Datatype.of(fieldType);
        // If not scalar, determine whether it is an enum
        if (datatype == null && isEnum(fullyQualifiedName(type, field.type().toString()))) {
          datatype = Datatype.ENUM;
        }
        if (datatype != null) types.add(datatype);

        // Convert Protoparser label to Wire label
        FieldElement.Label label = field.label();
        switch (label) {
          case OPTIONAL:
            labels.add(Label.OPTIONAL);
            break;
          case REQUIRED:
            labels.add(Label.REQUIRED);
            break;
          case REPEATED:
            if (FieldInfo.isPacked(field, datatype == Datatype.ENUM)) {
              labels.add(Label.PACKED);
            } else {
              labels.add(Label.REPEATED);
            }
            break;
          case ONE_OF:
            labels.add(Label.ONE_OF);
            break;
          default:
            throw new AssertionError("Unknown label " + label);
        }
      }

      for (TypeElement nestedType : type.nestedElements()) {
        getDatatypesAndLabels(nestedType, types, labels);
      }
    }
  }

  private boolean typeIsComplete(String type) {
    return javaSymbolMap.containsKey(type);
  }

  private boolean javaTypeIsComplete(String type) {
    if (javaSymbols.isEmpty()) {
      javaSymbols.addAll(javaSymbolMap.values());
    }
    return javaSymbols.contains(type);
  }

  private String fullyQualifiedJavaName(MessageElement messageType, String type) {
    return TypeInfo.isScalar(type) ? null : javaName(fullyQualifiedName(messageType, type));
  }
}
