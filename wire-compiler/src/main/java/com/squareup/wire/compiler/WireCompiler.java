// Copyright 2013 Square, Inc.
package com.squareup.wire.compiler;

import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.EnumType;
import com.squareup.protoparser.ExtendDeclaration;
import com.squareup.protoparser.MessageType;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.ProtoSchemaParser;
import com.squareup.protoparser.Type;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import javax.lang.model.element.Modifier;

import static com.squareup.protoparser.MessageType.Field;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

/** Compiler for Wire protocol buffers. */
public class WireCompiler {

  private static final Charset UTF_8 = Charset.forName("UTF8");
  private static final Map<String, String> JAVA_TYPES = new HashMap<String, String>();
  private static final Set<String> PACKABLE_TYPES = new HashSet<String>();
  private static final Set<String> JAVA_KEYWORDS = new HashSet<String>(
      Arrays.asList("abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
          "class", "const", "continue", "default", "do", "double", "else", "enum", "extends",
          "final", "finally", "float", "for", "goto", "if", "implements", "import", "instanceof",
          "int", "interface", "long", "native", "new", "package", "private", "protected", "public",
          "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
          "throw", "throws", "transient", "try", "void", "volatile", "while"));
  private static final String PROTO_PATH_FLAG = "--proto_path=";
  private static final String JAVA_OUT_FLAG = "--java_out=";
  private static final String FILES_FLAG = "--files=";
  private static final String URL_CHARS = "[-!#$%&'()*+,./0-9:;=?@A-Z\\[\\]_a-z~]";

  static {
    JAVA_TYPES.put("bool", "Boolean");
    JAVA_TYPES.put("bytes", "ByteString");
    JAVA_TYPES.put("double", "Double");
    JAVA_TYPES.put("float", "Float");
    JAVA_TYPES.put("fixed32", "Integer");
    JAVA_TYPES.put("fixed64", "Long");
    JAVA_TYPES.put("int32", "Integer");
    JAVA_TYPES.put("int64", "Long");
    JAVA_TYPES.put("sfixed32", "Integer");
    JAVA_TYPES.put("sfixed64", "Long");
    JAVA_TYPES.put("sint32", "Integer");
    JAVA_TYPES.put("sint64", "Long");
    JAVA_TYPES.put("string", "String");
    JAVA_TYPES.put("uint32", "Integer");
    JAVA_TYPES.put("uint64", "Long");

    PACKABLE_TYPES.add("bool");
    PACKABLE_TYPES.add("double");
    PACKABLE_TYPES.add("float");
    PACKABLE_TYPES.add("fixed32");
    PACKABLE_TYPES.add("fixed64");
    PACKABLE_TYPES.add("int32");
    PACKABLE_TYPES.add("int64");
    PACKABLE_TYPES.add("sfixed32");
    PACKABLE_TYPES.add("sfixed64");
    PACKABLE_TYPES.add("sint32");
    PACKABLE_TYPES.add("sint64");
    PACKABLE_TYPES.add("uint32");
    PACKABLE_TYPES.add("uint64");
  }
  private static final String CODE_GENERATED_BY_WIRE_PROTOBUF_COMPILER_DO_NOT_EDIT =
      "Code generated by Wire protobuf compiler, do not edit.";
  private final String repoPath;
  private final ProtoFile protoFile;
  private final Set<String> loadedDependencies = new HashSet<String>();
  private final Map<String, String> javaSymbolMap = new HashMap<String, String>();
  private final Set<String> enumTypes = new HashSet<String>();
  private final Map<String, String> enumDefaults = new HashMap<String, String>();
  private String protoFileName;
  private String typeBeingGenerated = "";
  private JavaWriter writer;

  public WireCompiler(String protoPath, String sourceFilename) throws IOException {
    this.repoPath = protoPath;
    String filename = protoPath + "/" + sourceFilename;
    System.out.println("Reading proto source file " + filename);
    this.protoFile = ProtoSchemaParser.parse(new File(protoPath + "/" + sourceFilename));
  }

  /**
   * Runs the compiler. Usage:
   *
   * <pre>
   * java WireCompiler --proto_path=<path> --java_out=<path> [--files=<protos.include>]
   *     [file [file...]]
   * </pre>
   */
  public static void main(String... args) throws Exception {
    String protoPath = null;
    String javaOut = null;
    List<String> sourceFilenames = new ArrayList<String>();

    int index = 0;
    while (index < args.length) {
      if (args[index].startsWith(PROTO_PATH_FLAG)) {
        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
      } else if (args[index].startsWith(FILES_FLAG)) {
        File files = new File(args[index].substring(FILES_FLAG.length()));
        String[] filenames = new Scanner(files, "UTF8").useDelimiter("\\A").next().split("\n");
        sourceFilenames.addAll(Arrays.asList(filenames));
      } else {
        sourceFilenames.add(args[index]);
      }
      index++;
    }
    if (protoPath == null) {
      System.err.println("Must specify " + PROTO_PATH_FLAG + " flag");
      System.exit(1);
    }
    if (javaOut == null) {
      System.err.println("Must specify " + JAVA_OUT_FLAG + " flag");
      System.exit(1);
    }
    for (String sourceFilename : sourceFilenames) {
      WireCompiler wireCompiler = new WireCompiler(protoPath, sourceFilename);
      wireCompiler.compile(javaOut);
    }
  }

  public JavaWriter getJavaWriter(String javaOut, String className) throws IOException {
    String javaPackage = protoFile.getJavaPackage();
    String directory = javaOut + "/" + javaPackage.replace(".", "/");
    boolean created = new File(directory).mkdirs();
    if (created) {
      System.out.println("Created output directory " + directory);
    }

    String fileName = directory + "/" + className + ".java";
    System.out.println("Writing generated code to " + fileName);
    return new JavaWriter(new OutputStreamWriter(new FileOutputStream(fileName), UTF_8));
  }

  public void compile(String javaOut) throws IOException {
    protoFileName = protoFileName(protoFile.getFileName());
    loadSymbols(protoFile);

    if (hasExtends()) {
      try {
        writer = getJavaWriter(javaOut, "Ext_" + protoFileName);
        emitExtensionClass();
      } finally {
        writer.close();
      }
    }

    for (Type type : protoFile.getTypes()) {
      String savedType = typeBeingGenerated;
      typeBeingGenerated += type.getName() + ".";
      emitMessageClass(javaOut, type);
      typeBeingGenerated = savedType;
    }
  }

  private void loadSymbols(ProtoFile protoFile) throws IOException {
    // Load symbols from imports
    for (String dependency : protoFile.getDependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        File dep = new File(repoPath + "/" + dependency);
        ProtoFile dependencyFile = ProtoSchemaParser.parse(dep);
        loadSymbols(dependencyFile);
        loadedDependencies.add(dependency);
      }
    }

    addTypes(protoFile.getTypes(), protoFile.getJavaPackage() + ".");
  }

  private void addTypes(List<Type> types, String javaPrefix) {
    for (Type type : types) {
      String name = type.getName();
      String fqName = type.getFullyQualifiedName();
      javaSymbolMap.put(fqName, javaPrefix + name);
      if (type instanceof EnumType) {
        enumTypes.add(fqName);
        enumDefaults.put(fqName, ((EnumType) type).getValues().get(0).getName());
      }
      addTypes(type.getNestedTypes(), javaPrefix + name + ".");
    }
  }

  private String protoFileName(String path) {
    int rindex = path.lastIndexOf('/');
    if (rindex != -1) {
      path = path.substring(rindex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  private void emitMessageClass(String javaOut, Type type) throws IOException {
    try {
      writer = getJavaWriter(javaOut, type.getName());
      writer.emitJavadoc(CODE_GENERATED_BY_WIRE_PROTOBUF_COMPILER_DO_NOT_EDIT + "\nSource file: %s",
          protoFile.getFileName());
      writer.emitPackage(protoFile.getJavaPackage());

      List<Type> types = new ArrayList<Type>();
      getTypes(type, types);
      boolean hasMessage = hasMessage(types);
      boolean hasExtensions = hasExtensions(Arrays.asList(type));

      Set<String> imports = new HashSet<String>();
      if (hasMessage) {
        imports.add("com.squareup.wire.Message");
      }
      if (hasMessage || hasExtensions) {
        if (hasFields(type)) {
          imports.add("com.squareup.wire.ProtoField");
        }
      }
      if (hasBytesField(types)) {
        imports.add("com.squareup.wire.ByteString");
      }
      if (hasEnum(types)) {
        imports.add("com.squareup.wire.ProtoEnum");
      }
      if (hasRepeatedField(types)) {
        imports.add("java.util.Collections");
        imports.add("java.util.List");
      }
      if (hasExtensions) {
        imports.add("com.squareup.wire.ExtendableMessage");
        imports.add("com.squareup.wire.Extension");
      }
      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(type, externalTypes);
      imports.addAll(externalTypes);
      writer.emitImports(imports);

      emitType(type, protoFile.getPackageName() + ".", true);
    } finally {
      writer.close();
    }
  }

  private void getTypes(Type root, List<Type> types) {
    types.add(root);
    for (Type nestedType : root.getNestedTypes()) {
      getTypes(nestedType, types);
    }
  }

  private void getExternalTypes(Type root, List<String> types) {
    if (root instanceof MessageType) {
      MessageType messageType = (MessageType) root;
      for (Field field : messageType.getFields()) {
        String fqName = fqJavaName(messageType, field.getType());
        if (fqName != null && !fqName.startsWith(protoFile.getJavaPackage())) {
          types.add(fqName);
        }
      }
    }
    for (Type nestedType : root.getNestedTypes()) {
      getExternalTypes(nestedType, types);
    }
  }

  private List<String> getExtensionTypes() {
    List<String> extensionClasses = new ArrayList<String>();
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String fullyQualifiedName = extend.getFullyQualifiedName();
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      // Only include names outside our own package
      if (typeIsQualified(name)) {
        extensionClasses.add(name);
      }
    }
    return extensionClasses;
  }

  private boolean hasExtends() {
    return !protoFile.getExtendDeclarations().isEmpty();
  }

  private void emitExtensionClass() throws IOException {
    writer.emitJavadoc(CODE_GENERATED_BY_WIRE_PROTOBUF_COMPILER_DO_NOT_EDIT + "\nSource file: %s",
        protoFile.getFileName());
    writer.emitPackage(protoFile.getJavaPackage());

    Set<String> imports = new HashSet<String>();
    if (hasByteStringExtension()) {
      imports.add("com.squareup.wire.ByteString");
    }
    imports.add("com.squareup.wire.Extension");
    imports.add("com.squareup.wire.Message");
    imports.add("java.util.List");
    imports.addAll(getExtensionTypes());
    writer.emitImports(imports);
    writer.emitEmptyLine();

    String className = "Ext_" + protoFileName;
    writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
    writer.emitEmptyLine();

    // Private no-args constructor
    writer.beginMethod(null, className, EnumSet.of(PRIVATE));
    writer.endMethod();
    writer.emitEmptyLine();

    emitExtensions();
    writer.endType();
  }

  private void emitExtensions() throws IOException {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      String fullyQualifiedName = extend.getFullyQualifiedName();
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        String type = javaName(null, fieldType);
        boolean isEnum = isEnum(fieldType);
        if (type == null) {
          String qualifiedFieldType = protoFile.getPackageName() + "." + fieldType;
          isEnum = isEnum(qualifiedFieldType);
          type = javaName(null, qualifiedFieldType);
        }
        type = shortenJavaName(type);
        String initialValue;
        String className = writer.compressType(name);
        int tag = field.getTag();
        if (isScalar(field)) {
          if (isRepeated(field)) {
            initialValue =
                String.format("Extension.getRepeatedExtension(%s.class, %s, Message.%s, %s)",
                    className, tag, protoFieldType(field.getType()), isPacked(field, false));
          } else {
            initialValue =
                String.format("Extension.getExtension(%s.class, %s, Message.%s, Message.%s)",
                    className, tag, protoFieldType(field.getType()), field.getLabel());
          }
        } else if (isEnum) {
          if (isRepeated(field)) {
            initialValue =
                String.format("Extension.getRepeatedEnumExtension(%s.class, %s, %s, %s.class)",
                    className, tag, isPacked(field, true), type);
          } else {
            initialValue =
                String.format("Extension.getEnumExtension(%s.class, %s, Message.%s, %s.class)",
                    className, tag, field.getLabel(), type);
          }
        } else {
          if (isRepeated(field)) {
            initialValue =
                String.format("Extension.getRepeatedMessageExtension(%s.class, %s, %s.class)",
                    className, tag, type);
          } else {
            initialValue =
                String.format("Extension.getMessageExtension(%s.class, %s, Message.%s, %s.class)",
                    className, tag, field.getLabel(), type);
          }
        }
        if (isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", field.getName(),
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  private boolean hasByteStringExtension() {
    for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
      for (MessageType.Field field : extend.getFields()) {
        String fieldType = field.getType();
        if ("bytes".equals(fieldType)) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasExtensions(MessageType messageType) {
    return !messageType.getExtensions().isEmpty();
  }

  private void emitType(Type type, String currentType, boolean topLevel) throws IOException {
    writer.emitEmptyLine();
    if (type instanceof MessageType) {
      MessageType messageType = (MessageType) type;
      boolean hasExtensions = hasExtensions(messageType);

      String name = type.getName();
      Set<Modifier> modifiers = EnumSet.of(PUBLIC, FINAL);
      if (!topLevel) {
        modifiers.add(STATIC);
      }
      writer.beginType(name, "class", modifiers,
          hasExtensions ? "ExtendableMessage<" + name + ">" : "Message");
      emitMessageDefaults(messageType);
      emitMessageFields(messageType);
      emitMessageConstructor(messageType);
      emitMessageEquals(messageType);
      emitMessageHashCode(messageType);
      emitBuilder(messageType);

      for (Type nestedType : type.getNestedTypes()) {
        emitType(nestedType, currentType + nestedType.getName() + ".", false);
      }

      writer.endType();
    } else if (type instanceof EnumType) {
      EnumType enumType = (EnumType) type;
      writer.beginType(enumType.getName(), "enum", EnumSet.of(PUBLIC));
      for (EnumType.Value value : enumType.getValues()) {
        writer.emitAnnotation(ProtoEnum.class, value.getTag());
        writer.emitEnumValue(value.getName());
      }
      writer.endType();
    }
  }

  // Example:
  //
  // public static final Integer DEFAULT_OPT_INT32 = 123;
  //
  private void emitMessageDefaults(MessageType messageType) throws IOException {
    List<Field> fields = messageType.getFields();
    if (!fields.isEmpty()) {
      writer.emitEmptyLine();
    }
    for (Field field : fields) {
      String javaName = getJavaType(messageType, field);
      if (javaName == null) {
        throw new IllegalArgumentException(
            "Unknown type for field " + field + " in message " + messageType.getName());
      }
      String defaultValue = getDefaultValue(messageType, field);

      writer.emitField(javaName, "DEFAULT_" + sanitize(field.getName()).toUpperCase(Locale.US),
          EnumSet.of(PUBLIC, STATIC, FINAL), defaultValue);
    }
  }

  private String getJavaType(MessageType messageType, Field field) {
    String javaName = javaName(messageType, field.getType());
    if (isRepeated(field)) javaName = "List<" + javaName + ">";
    return javaName;
  }

  private String sanitize(String name) {
    if (JAVA_KEYWORDS.contains(name)) {
      return "_" + name;
    }
    return name;
  }

  private String getDefaultValue(MessageType messageType, Field field) {
    String initialValue = field.getDefault();
    // Qualify message and enum values
    if (isRepeated(field)) return "Collections.emptyList()";
    String javaName = javaName(messageType, field.getType());
    if (isScalar(field)) {
      return getInitializerForType(initialValue, javaName);
    } else {
      if (initialValue != null) {
        return javaName + "." + initialValue;
      } else {
        String fullyQualifiedName = fullyQualifiedName(messageType, field.getType());
        if (isEnum(fullyQualifiedName)) {
          return javaName + "." + enumDefaults.get(fullyQualifiedName);
        } else {
          return "getDefaultInstance(" + writer.compressType(javaName) + ".class)";
        }
      }
    }
  }

  private String getInitializerForType(String initialValue, String javaTypeName) {
    if ("Boolean".equals(javaTypeName)) {
      return initialValue == null ? "false" : initialValue;
    } else if ("Double".equals(javaTypeName)) {
      return initialValue == null ? "0D" : initialValue + "D";
    } else if ("Integer".equals(javaTypeName)) {
      // Wrap unsigned values
      return initialValue == null ? "0" : toInt(initialValue);
    } else if ("Long".equals(javaTypeName)) {
      // Wrap unsigned values and add an 'L'
      return initialValue == null ? "0L" : toLong(initialValue) + "L";
    } else if ("Float".equals(javaTypeName)) {
      return initialValue == null ? "0F" : initialValue + "F";
    } else if ("String".equals(javaTypeName)) {
      return quoteString(initialValue);
    } else if ("ByteString".equals(javaTypeName)) {
      return "ByteString.of(" + quoteString(initialValue) + ")";
    } else {
      return "null";
    }
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue());
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  // Example:
  //
  // /**
  //  * An optional int32
  //  */
  // @ProtoField(
  //   tag = 1,
  //   type = INT32
  // )
  // public final Integer optional_int32;
  //
  private void emitMessageFields(MessageType messageType) throws IOException {
    for (Field field : messageType.getFields()) {
      String javaName = javaName(messageType, field.getType());
      Map<String, String> map = new LinkedHashMap<String, String>();
      map.put("tag", String.valueOf(field.getTag()));

      String type = field.getType();
      boolean isEnum = false;
      if (isScalar(field)) {
        map.put("type", protoFieldType(type));
      } else {
        String fullyQualifiedName = fullyQualifiedName(messageType, type);
        isEnum = isEnum(fullyQualifiedName);
        if (isEnum) map.put("type", "ENUM");
      }

      if (isPacked(field, isEnum)) map.put("packed", "true");
      if (!isOptional(field)) map.put("label", field.getLabel().toString());

      writer.emitEmptyLine();
      String documentation = field.getDocumentation();
      if (hasDocumentation(documentation)) {
        writer.emitJavadoc(sanitizeJavadoc(documentation));
      }
      writer.emitAnnotation(ProtoField.class, map);

      if (isRepeated(field)) javaName = "List<" + javaName + ">";
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC, FINAL));
    }
  }

  /**
   * A grab-bag of fixes for things that can go wrong when converting to javadoc.
   */
  private String sanitizeJavadoc(String documentation) {
    // JavaWriter will pass the doc through String.format, so escape all '%' chars
    documentation = documentation.replace("%", "%%");
    // Rewrite '@see <url>' to use an html anchor tag
    documentation =
        documentation.replaceAll("@see (http:" + URL_CHARS + "+)", "@see <a href=\"$1\">$1</a>");
    return documentation;
  }

  // Example:
  //
  // private SimpleMessage(Builder builder) {
  //   super(builder);
  //   this.optional_int32 = builder.optional_int32;
  // }
  //
  private void emitMessageConstructor(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, messageType.getName(), EnumSet.of(PRIVATE), "Builder", "builder");
    writer.emitStatement("super(builder)");
    for (Field field : messageType.getFields()) {
      if (isRepeated(field)) {
        writer.emitStatement("this.%1$s = unmodifiableCopyOf(builder.%1$s)",
            sanitize(field.getName()));
      } else {
        writer.emitStatement("this.%1$s = builder.%1$s", sanitize(field.getName()));
      }
    }
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public boolean equals(Object other) {
  //   if (!(other instanceof SimpleMessage)) return false;
  //   SimpleMessage o = (SimpleMessage) other;
  //   if (!Wire.equals(optional_int32, o.optional_int32)) return false;
  //   return true;
  //
  private void emitMessageEquals(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("boolean", "equals", EnumSet.of(PUBLIC), "Object", "other");

    List<Field> fields = messageType.getFields();
    if (fields.isEmpty()) {
      writer.emitStatement("return other instanceof %s", messageType.getName());
    } else {
      writer.emitStatement("if (!(other instanceof %s)) return false", messageType.getName());
      if (hasOnlyOneField(messageType)) {
        writer.emitStatement("return equals(%1$s, ((%2$s) other).%1$s)",
            sanitize(fields.get(0).getName()), messageType.getName());
      } else {
        writer.emitStatement("%1$s o = (%1$s) other", messageType.getName());
        if (hasExtensions(messageType)) {
          writer.emitStatement("if (!extensionsEqual(o)) return false");
        }
        for (Field field : fields) {
          writer.emitStatement("if (!equals(%1$s, o.%1$s)) return false",
              sanitize(field.getName()));
        }
        writer.emitStatement("return true");
      }
    }
    writer.endMethod();
  }

  private boolean hasOnlyOneField(MessageType messageType) {
    return messageType.getFields().size() == 1 && !hasExtensions(messageType);
  }

  // Example:
  //
  // @Override
  // public int hashCode() {
  //   if (hashCode == 0) {
  //     int result = super.extensionsHashCode();
  //     result = result * 37 + (f != null ? f.hashCode() : 0);
  //     hashCode = result;
  //   }
  //   return hashCode;
  // }
  //
  private void emitMessageHashCode(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("int", "hashCode", EnumSet.of(PUBLIC));

    if (!hasFields(messageType) && !hasExtensions(messageType)) {
      writer.emitStatement("return 0");
    } else if (hasOnlyOneField(messageType)) {
      Field field = messageType.getFields().get(0);
      String name = sanitize(field.getName());
      writer.emitStatement("int result = hashCode");
      writer.emitStatement(
          "return result != 0 ? result : (hashCode = %1$s != null ? %1$s.hashCode() : 0)", name);
    } else {
      writer.emitStatement("int result = hashCode");
      writer.beginControlFlow("if (result == 0)");
      boolean afterFirstAssignment = false;
      if (hasExtensions(messageType)) {
        writer.emitStatement("result = extensionsHashCode()");
        afterFirstAssignment = true;
      }
      for (Field field : messageType.getFields()) {
        String name = sanitize(field.getName());
        if (afterFirstAssignment) {
          writer.emitStatement("result = result * 37 + (%1$s != null ? %1$s.hashCode() : 0)", name);
        } else {
          writer.emitStatement("result = %1$s != null ? %1$s.hashCode() : 0", name);
          afterFirstAssignment = true;
        }
      }
      writer.emitStatement("hashCode = result");
      writer.endControlFlow();
      writer.emitStatement("return result");
    }
    writer.endMethod();
  }

  private void emitBuilder(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginType("Builder", "class", EnumSet.of(PUBLIC, STATIC, FINAL),
        (hasExtensions(messageType) ? "ExtendableBuilder<" : "Message.Builder<")
            + messageType.getName()
            + ">");
    emitBuilderFields(messageType);
    emitBuilderConstructors(messageType);
    emitBuilderSetters(messageType);
    if (hasExtensions(messageType)) emitBuilderSetExtension(messageType);
    emitBuilderBuild(messageType);
    writer.endType();
  }

  private void emitBuilderFields(MessageType messageType) throws IOException {
    List<Field> fields = messageType.getFields();

    if (!fields.isEmpty()) writer.emitEmptyLine();
    for (Field field : fields) {
      String javaName = getJavaType(messageType, field);
      writer.emitField(javaName, sanitize(field.getName()), EnumSet.of(PUBLIC));
    }
  }

  // Example:
  //
  // public Builder() {
  // }
  //
  // public Builder(SimpleMessage message) {
  //   super(message);
  //   if (message == null) return;
  //   this.optional_int32 = message.optional_int32;
  //   ...
  // }
  //
  private void emitBuilderConstructors(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC));
    writer.endMethod();

    writer.emitEmptyLine();
    writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC), messageType.getName(), "message");
    writer.emitStatement("super(message)");
    List<Field> fields = messageType.getFields();
    if (!fields.isEmpty()) writer.emitStatement("if (message == null) return");
    for (Field field : fields) {
      if (isRepeated(field)) {
        writer.emitStatement("this.%1$s = copyOf(message.%1$s)", sanitize(field.getName()));
      } else {
        writer.emitStatement("this.%1$s = message.%1$s", sanitize(field.getName()));
      }
    }
    writer.endMethod();
  }

  private void emitBuilderSetters(MessageType messageType) throws IOException {
    for (Field field : messageType.getFields()) {
      String javaName = getJavaType(messageType, field);
      List<String> args = new ArrayList<String>();
      args.add(javaName);
      String sanitized = sanitize(field.getName());
      args.add(sanitized);

      writer.emitEmptyLine();
      writer.beginMethod("Builder", sanitized, EnumSet.of(PUBLIC), args, null);
      writer.emitStatement("this.%1$s = %1$s", sanitized);
      writer.emitStatement("return this");
      writer.endMethod();
    }
  }

  // Example:
  //
  // @Override
  // public <E> Builder setExtension(Extension<ExternalMessage, E> extension, E value) {
  //   super.setExtension(extension, value);
  //   return this;
  // }
  //
  private void emitBuilderSetExtension(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod("<E> Builder", "setExtension", EnumSet.of(PUBLIC),
        "Extension<" + messageType.getName() + ", E>", "extension", "E", "value");
    writer.emitStatement("super.setExtension(extension, value)");
    writer.emitStatement("return this");
    writer.endMethod();
  }

  // Example:
  //
  // @Override
  // public SimpleMessage build() {
  //   checkRequiredFields();
  //   return new SimpleMessage(this);
  // }
  //
  // The call to checkRequiredFields will be emitted only if the message has
  // required fields.
  //
  private void emitBuilderBuild(MessageType messageType) throws IOException {
    writer.emitEmptyLine();
    writer.emitAnnotation(Override.class);
    writer.beginMethod(messageType.getName(), "build", EnumSet.of(PUBLIC));
    if (hasRequiredFields(messageType)) {
      writer.emitStatement("checkRequiredFields()");
    }
    writer.emitStatement("return new %s(this)", messageType.getName());
    writer.endMethod();
  }

  private boolean hasEnum(List<Type> types) {
    for (Type type : types) {
      if (type instanceof EnumType || hasEnum(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasExtensions(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType && hasExtensions(((MessageType) type))) return true;
      if (hasExtensions(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasMessage(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType && !hasExtensions(((MessageType) type))) return true;
      if (hasMessage(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasRepeatedField(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType) {
        for (Field field : ((MessageType) type).getFields()) {
          if (isRepeated(field)) return true;
        }
      }
      if (hasRepeatedField(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasBytesField(List<Type> types) {
    for (Type type : types) {
      if (type instanceof MessageType) {
        for (Field field : ((MessageType) type).getFields()) {
          if ("bytes".equals(field.getType())) return true;
        }
      }
      if (hasBytesField(type.getNestedTypes())) return true;
    }
    return false;
  }

  private boolean hasFields(Type type) {
    return type instanceof MessageType && !((MessageType) type).getFields().isEmpty();
  }

  private boolean hasRequiredFields(Type type) {
    if (type instanceof MessageType) {
      for (MessageType.Field field : ((MessageType) type).getFields()) {
        if (isRequired(field)) return true;
      }
    }
    return false;
  }

  private boolean hasDocumentation(String documentation) {
    return documentation != null && !documentation.isEmpty();
  }

  private String protoFieldType(String type) {
    if (isScalar(type)) {
      return type.toUpperCase(Locale.US);
    } else {
      return type + ".class";
    }
  }

  private boolean isScalar(Field field) {
    return isScalar(field.getType());
  }

  private boolean isScalar(String type) {
    return JAVA_TYPES.containsKey(type);
  }

  private String scalarType(String type) {
    return JAVA_TYPES.get(type);
  }

  private boolean isEnum(String fieldType) {
    return enumTypes.contains(fieldType);
  }

  private boolean isOptional(Field field) {
    return field.getLabel() == MessageType.Label.OPTIONAL;
  }

  private boolean isRepeated(Field field) {
    return field.getLabel() == MessageType.Label.REPEATED;
  }

  private boolean isRequired(Field field) {
    return field.getLabel() == MessageType.Label.REQUIRED;
  }

  private boolean isPacked(Field field, boolean isEnum) {
    return "true".equals(field.getExtensions().get("packed")) && (PACKABLE_TYPES.contains(
        field.getType()) || isEnum);
  }

  private String fullyQualifiedName(MessageType messageType, String type) {
    if (typeIsQualified(type)) {
      return type;
    } else {
      String prefix = messageType.getFullyQualifiedName();
      while (prefix.contains(".")) {
        String fqname = prefix + "." + type;
        if (javaSymbolMap.containsKey(fqname)) return fqname;
        prefix = prefix.substring(0, prefix.lastIndexOf('.'));
      }
    }
    throw new RuntimeException("Unknown type " + type + " in message " + messageType.getName());
  }

  private String javaName(MessageType messageType, String type) {
    String scalarType = scalarType(type);
    return scalarType != null ? scalarType : shortenJavaName(findJavaName(messageType, type));
  }

  private String fqJavaName(MessageType messageType, String type) {
    return isScalar(type) ? null : findJavaName(messageType, type);
  }

  private String findJavaName(MessageType messageType, String type) {
    // Assume names containing a '.' are already fully-qualified
    if (typeIsQualified(type)) {
      return javaSymbolMap.get(type);
    } else {
      String prefix = messageType != null ? messageType.getFullyQualifiedName() : "";
      while (prefix.contains(".")) {
        String fqname = prefix + "." + type;
        String javaName = javaSymbolMap.get(fqname);
        if (javaName != null) return javaName;
        prefix = prefix.substring(0, prefix.lastIndexOf('.'));
      }
    }
    return null;
  }

  private String shortenJavaName(String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaPackage = protoFile.getJavaPackage() + ".";
    fullyQualifiedName = removePrefixIfPresent(fullyQualifiedName, javaPackage);
    fullyQualifiedName = removePrefixIfPresent(fullyQualifiedName, typeBeingGenerated);
    return fullyQualifiedName;
  }

  private String removePrefixIfPresent(String s, String prefix) {
    return s.startsWith(prefix) ? s.substring(prefix.length()) : s;
  }

  private boolean typeIsQualified(String type) {
    return type.contains(".");
  }
}
