/*
 * Copyright (C) 2016 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.wire.sample

import com.google.common.base.Stopwatch
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.TypeSpec
import com.squareup.wire.java.JavaGenerator
import com.squareup.wire.schema.Location
import com.squareup.wire.schema.PruningRules
import com.squareup.wire.schema.Schema
import com.squareup.wire.schema.SchemaLoader
import java.io.File
import java.io.IOException

/**
 * Reads in .proto files, links ’em together, prunes ’em, and emits both types and services. This
 * can be used to either complement or replace `WireCompiler`.
 */
class CodegenSample(
  private val log: Log,
  private val sources: Set<String>,
  private val protos: Set<String>,
  private val generatedSourceDirectory: String,
  private val pruningRules: PruningRules
) {
  @Throws(IOException::class)
  fun execute() {
    var schema = loadSchema()

    if (!pruningRules.isEmpty) {
      schema = retainRoots(schema)
    }

    val javaGenerator = JavaGenerator.get(schema)
    val serviceGenerator = ServiceGenerator(javaGenerator)
    for (protoFile in schema.protoFiles) {
      for (type in protoFile.types) {
        val stopwatch = Stopwatch.createStarted()
        val typeSpec = javaGenerator.generateType(type)
        val javaTypeName = javaGenerator.typeName(type.type) as ClassName
        writeJavaFile(javaTypeName, typeSpec, type.location, stopwatch)
      }
      for (service in protoFile.services) {
        val stopwatch = Stopwatch.createStarted()
        val javaTypeName = javaGenerator.typeName(service.type()) as ClassName
        val typeSpec = serviceGenerator.api(service)
        writeJavaFile(javaTypeName, typeSpec, service.location(), stopwatch)
      }
    }
  }

  @Throws(IOException::class)
  private fun loadSchema(): Schema {
    val stopwatch = Stopwatch.createStarted()
    val loader = SchemaLoader()
    for (source in sources) {
      loader.addSource(File(source))
    }
    for (proto in protos) {
      loader.addProto(proto)
    }
    val schema = loader.load()
    log.info("Loaded %s proto files in %s", schema.protoFiles.size, stopwatch)
    return schema
  }

  private fun retainRoots(schema: Schema): Schema {
    val stopwatch = Stopwatch.createStarted()
    val oldSize = countTypes(schema)

    val prunedSchema = schema.prune(pruningRules)
    val newSize = countTypes(prunedSchema)

    log.info("Pruned schema from %s types to %s types in %s", oldSize, newSize, stopwatch)

    return prunedSchema
  }

  @Throws(IOException::class)
  private fun writeJavaFile(
    javaTypeName: ClassName,
    typeSpec: TypeSpec,
    location: Location?,
    stopwatch: Stopwatch
  ) {
    val builder = JavaFile.builder(javaTypeName.packageName(), typeSpec)
          .addFileComment("Code generated by \$L, do not edit.", CodegenSample::class.java.name)
    if (location != null) {
      builder.addFileComment("\nSource file: \$L", location.path)
    }
    val javaFile = builder.build()
    try {
      javaFile.writeTo(File(generatedSourceDirectory))
    } catch (e: IOException) {
      throw IOException(
          "Failed to write ${javaFile.packageName}.${javaFile.typeSpec.name} to $generatedSourceDirectory", e
      )
    }
    log.info("Generated %s in %s", javaTypeName, stopwatch)
  }

  private fun countTypes(prunedSchema: Schema): Int {
    var result = 0
    for (protoFile in prunedSchema.protoFiles) {
      result += protoFile.types.size
    }
    return result
  }

  interface Log {
    fun info(
      format: String,
      vararg args: Any
    )
  }
}
